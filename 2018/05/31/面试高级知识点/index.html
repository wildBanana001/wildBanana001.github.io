<!DOCTYPE html>
<html style="display: none;" >
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.2 -->
    <script>
        window.materialVersion = "1.5.2"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1',
            '1.5.0'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">














    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!-- Title -->
    
    <title>
        
            面试高级知识点 (持续更新) | 
        
        BLOG
    </title>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">

    <meta name="format-detection" content="telephone=no"/>
    <meta name="description" itemprop="description" content="">
    <meta name="keywords" content=",Es6 异步 原型 vdom MVVM 组件化 hybrid">
    <meta name="theme-color" content="#0097A7">

    <!-- Disable Fucking Bloody Baidu Tranformation -->
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.en.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(a){try{localStorage.removeItem(a)}catch(b){}};lsloader.setLS=function(a,c){try{localStorage.setItem(a,c)}catch(b){}};lsloader.getLS=function(a){var c="";try{c=localStorage.getItem(a)}catch(b){c=""}return c};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var b=[];for(var a=0;a<localStorage.length;a++){b.push(localStorage.key(a))}b.forEach(function(e){var f=lsloader.getLS(e);if(window.oldVersion){var d=window.oldVersion.reduce(function(g,h){return g||f.indexOf("/*"+h+"*/")!==-1},false);if(d){lsloader.removeLS(e)}}})}catch(c){}};lsloader.clean();lsloader.load=function(f,a,b,d){if(typeof b==="boolean"){d=b;b=undefined}d=d||false;b=b||function(){};var e;e=this.getLS(f);if(e&&e.indexOf(versionString)===-1){this.removeLS(f);this.requestResource(f,a,b,d);return}if(e){var c=e.split(versionString)[0];if(c!=a){console.log("reload:"+a);this.removeLS(f);this.requestResource(f,a,b,d);return}e=e.split(versionString)[1];if(d){this.jsRunSequence.push({name:f,code:e});this.runjs(a,f,e)}else{document.getElementById(f).appendChild(document.createTextNode(e));b()}}else{this.requestResource(f,a,b,d)}};lsloader.requestResource=function(b,e,a,c){var d=this;if(c){this.iojs(e,b,function(h,f,g){d.setLS(f,h+versionString+g);d.runjs(h,f,g)})}else{this.iocss(e,b,function(f){document.getElementById(b).appendChild(document.createTextNode(f));d.setLS(b,e+versionString+f)},a)}};lsloader.iojs=function(d,b,g){var a=this;a.jsRunSequence.push({name:b,code:""});try{var f=new XMLHttpRequest();f.open("get",d,true);f.onreadystatechange=function(){if(f.readyState==4){if((f.status>=200&&f.status<300)||f.status==304){if(f.response!=""){g(d,b,f.response);return}}a.jsfallback(d,b)}};f.send(null)}catch(c){a.jsfallback(d,b)}};lsloader.iocss=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.iofonts=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.runjs=function(f,c,e){if(!!c&&!!e){for(var b in this.jsRunSequence){if(this.jsRunSequence[b].name==c){this.jsRunSequence[b].code=e}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var a=document.createElement("script");a.appendChild(document.createTextNode(this.jsRunSequence[0].code));a.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(a);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else{if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var d=this;var a=document.createElement("script");a.src=this.jsRunSequence[0].path;a.type="text/javascript";this.jsRunSequence[0].status="loading";a.onload=function(){d.jsRunSequence.shift();if(d.jsRunSequence.length>0){d.runjs()}};document.body.appendChild(a)}}};lsloader.tagLoad=function(b,a){this.jsRunSequence.push({name:a,code:"",path:b,status:"failed"});this.runjs()};lsloader.jsfallback=function(c,b){if(!!this.jsnamemap[b]){return}else{this.jsnamemap[b]=b}for(var a in this.jsRunSequence){if(this.jsRunSequence[a].name==b){this.jsRunSequence[a].code="";this.jsRunSequence[a].status="failed";this.jsRunSequence[a].path=c}}this.runjs()};lsloader.cssfallback=function(e,c,b){if(!!this.cssnamemap[c]){return}else{this.cssnamemap[c]=1}var d=document.createElement("link");d.type="text/css";d.href=e;d.rel="stylesheet";d.onload=d.onerror=b;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(d,a)};lsloader.runInlineScript=function(c,b){var a=document.getElementById(b).innerText;this.jsRunSequence.push({name:c,code:a});this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?MKetZV3cUTfDxvMffaOezg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        

    

    
        
            <link rel="stylesheet" href="/css/fontawesome.min.css">
        
    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-image: url(/img/bg.png);
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icons -->


    <style id="material_icons"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_icons","/css/material-icons.css?pqhB/Rd/ab0H2+kZp0RDmw==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==", true)</script>
    

    <!-- WebAPP Icons -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="BLOG">
    <meta name="msapplication-starturl" content="http://yoursite.com/2018/05/31/面试高级知识点/">
    <meta name="msapplication-navbutton-color" content="#0097A7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="BLOG">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://yoursite.com/2018/05/31/面试高级知识点/">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="面试高级知识点 (持续更新) | BLOG">
    <meta property="og:image" content="/img/favicon.png">
    <meta property="og:description" content="">
    <meta property="og:article:tag" content="Es6 异步 原型 vdom MVVM 组件化 hybrid"> 

    
        <meta property="article:published_time" content="Thu May 31 2018 11:15:40 GMT+0800">
        <meta property="article:modified_time" content="Sun Jun 03 2018 18:30:09 GMT+0800">
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:card" content="summary_large_image">

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://yoursite.com/2018/05/31/面试高级知识点/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://yoursite.com/2018/05/31/面试高级知识点/index.html",
    "headline": "面试高级知识点 (持续更新)",
    "datePublished": "Thu May 31 2018 11:15:40 GMT+0800",
    "dateModified": "Sun Jun 03 2018 18:30:09 GMT+0800",
    "author": {
        "@type": "Person",
        "name": "林凯锋",
        "image": {
            "@type": "ImageObject",
            "url": "/img/myavatar.png"
        },
        "description": "github.com/wildBanana001"
    },
    "publisher": {
        "@type": "Organization",
        "name": "BLOG",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/favicon.png"
        }
    },
    "keywords": ",Es6 异步 原型 vdom MVVM 组件化 hybrid",
    "description": "",
}
</script>


    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head -->
    

</head>


    
        <body id="scheme-Isolation" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                
                    <!-- Isolation Header -->
                    <header class="header">
    <div class="header-wrapper">
        <!-- Header Copyright -->
        <div class="header-copyright">
            <div class="header-site">
                ©&nbsp;
                <script type="text/javascript">
                    var fd = new Date();
                    document.write(fd.getFullYear());
                </script>
                &nbsp;BLOG
            </div>
            <!--
            I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright.
            It will not impact the appearance and can give developers a lot of support :)

            很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
            它不会影响美观并可以给开发者很大的支持。 :)
            -->
            <div>
                Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a>
                <br>
                Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a>
            </div>
        </div>

        <!-- Header Title -->
        <span class="header-title header-item">
            <a href="/" title="BLOG">
                BLOG
            </a>
        </span>

        <p class="header-slogan header-item">
        
            
                github.com/wildBanana001
            
        
        </p>

        <!-- Header Nav -->
        <nav class="header-nav header-item">
            <span class="header-nav-item">
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </span>

            <!-- Pages  -->
            
            
        </nav>

        <!-- Header SNS -->
        <div class="header-item header-sns_list">
    <!-- Twitter -->
    
        <a href="https://twitter.com/twitter" target="_blank">
            <i class="fa fa-twitter fa-lg" aria-hidden="true"></i>
        </a>
    

    <!-- Facebook -->
    
        <a href="https://www.facebook.com/facebook" target="_blank">
            <i class="fa fa-facebook fa-lg" aria-hidden="true"></i>
        </a>
    

    <!-- Google + -->
    
        <a href="https://www.google.com/" target="_blank">
            <i class="fa fa-google-plus fa-lg" aria-hidden="true"></i>
        </a>
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    

    <!-- LinkedIn -->
    

    <!-- Telegram -->
    
</div>

    </div>
</header>

                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    

                    <!-- Post TOC -->

    



<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                


    <!-- Isolation Post Header -->
    <!-- Post thumbnail -->
    
        <!-- Post Header Info -->
        <div class="post-header_info without-thumbnail">
            <!-- Author Avatar & Name -->
            <img src="/img/myavatar.png" class="avatar-img" width="44px" height="44px" alt="林凯锋's avatar">
            <span class="name-span">林凯锋</span>
        </div>

        <!-- Null Thumbnail -->
        <div class="post_thumbnail-null">
    
        </div>



                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    

    
        <div class="post-content_wrapper">
            <p class="post-title">
                面试高级知识点 (持续更新)
            </p>
            <p>首先推荐一些网站：<br>社区：掘金，思否，CSDN<br>解决问题的网站： 官方文档是最权威的。stackoverflow.com，GitHub.com的Issues板块。</p>
<h2 id="面试高级知识点"><a href="#面试高级知识点" class="headerlink" title="面试高级知识点"></a>面试高级知识点</h2><h3 id="技术选型分析"><a href="#技术选型分析" class="headerlink" title="技术选型分析"></a>技术选型分析</h3><ol>
<li>构建工具</li>
<li>MVVM框架选择：学习成本，生态(插件体系、文档、作者维护热度),对原理的了解程度。Vuejs、Reactjs、Angularjs。</li>
<li>模块化设计：CSS模块化设计、JS模块化设计。</li>
<li>自适应方案设计</li>
<li>代码维护及复用性设计的思考：需求变更、产品迭代、Bug定位、新功能开发。</li>
</ol>
<h4 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h4><p>gulp、grunt、fis、prepack、webpack和rollup。</p>
<ul>
<li>使用构建工具的好处：资源压缩、静态资源替换、模块化处理、编译处理。</li>
<li>grunt负责任务管理，是输入输出操作，之后被gulp取代。gulp负责任务管理，IO流式操作。还是使用webpack主要负责编译打包。fis是百度内部推出的集成方案。prepack是facebook出的代码打包工具是即时的。</li>
</ul>
<h4 id="CSS模块化"><a href="#CSS模块化" class="headerlink" title="CSS模块化"></a>CSS模块化</h4><ul>
<li>设计原则： </li>
</ul>
<ol>
<li>可复用能继承要完整。</li>
<li>周期性迭代。</li>
</ol>
<ul>
<li>设计方法： </li>
</ul>
<ol>
<li>先整体后部分再颗粒化：布局-&gt;页面-&gt;功能-&gt;业务</li>
<li>先抽象再具体。</li>
</ol>
<p>使用SCSS作为预编译语言：<br>有变量、嵌套规则，导入等功能。<br>模块化让更多样式可以被复用，如颜色的定义、模块的定义、样式的继承等。</p>
<p>CSS模块化主要分成三种CSS：<br>reset.scss：兼容不同浏览器<br>layout.scss：写抽象布局样式<br>element.scss：具体颗粒化，写元素样式</p>
<p>CSS Module的工作原理就是把一个类名编译成哈希字符串，然后在引用的时候直接使用这个哈希字符串，进而保证相同的类名根据不同的路径和组件名称得到不同的值，保证最终的类名隔离。</p>
<p>Vue在Vue-loader中配置开启CSS Module<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在Vue官方文档上可以看到</span><br><span class="line">cssModules: &#123;</span><br><span class="line">    localIdentName: &apos;[path][name]---[local]---[hash:base64:5]&apos;,</span><br><span class="line">    camelCase: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Vue文件中style标签加上module属性：<code>&lt;style lang=&#39;scss&#39; module&gt;&lt;/style&gt;</code><br>对于父组件声明的类名，在子组件内CSS Module是不处理的，想用必须显示调用类名($style.类名)<br>使用@import引入第三方样式库。</p>
<p>问题：CSS Module 和<code>Vue&lt;style&gt;</code>的scoped属性有啥异同？</p>
<ul>
<li>相同点：两者都是为了解决CSS类名相互干扰的问题，也就是”作用域”问题。</li>
<li>不同点：</li>
</ul>
<ol>
<li>CSS Module是所有组件化框架都支持的技术方案，他不属于某个框架的私有属性。而scoped是Vue框架的私有属性。</li>
<li>CSS Module的工作原理大白话说就是把一个类名做md5，然后在引用的时候直接使用md5字符串，进而保证相同的类名根据不同的路径和组件名称得到不同的md5值，保证了最终的类名隔离。Scoped的做法是做命名空间限制，也就是说每个组件就是一个命名空间，每个命名空间拥有不同的类名(md5),然后在每个下面的类名都会挂在这个命名空间下进而达到隔离。</li>
<li>对于父组件的声明的类名，在子组件内，CSS Module是不处理的，想用必须显示调用类名($style.类名)，而使用scoped是因为命名空间的方式，所以子组件依然有效。</li>
</ol>
<h4 id="JS模块化"><a href="#JS模块化" class="headerlink" title="JS模块化"></a>JS模块化</h4><ul>
<li>设计原则</li>
</ul>
<ol>
<li>高内聚低耦合。</li>
<li>周期性迭代。</li>
</ol>
<ul>
<li>设计方法</li>
</ul>
<ol>
<li>先整体后部分再颗粒化。</li>
<li>尽可能的抽象。</li>
</ol>
<p>高内聚：组件的功能受控于组件本身，而不是依赖于其他组件。<br>低耦合：抽象出列表组件，但不包括实际的功能。<br>周期性迭代：反复优化代码。</p>
<p>对于组件复用性，第一步将功能组件和业务组件划分开，然后在功能组件上也要继续设计，不断抽象在去实现，这样可以满足更多应用，达到最大化复用，且随着业务如何变化，功能组件的稳定性都不会遭到破坏。</p>
<h4 id="自适应"><a href="#自适应" class="headerlink" title="自适应"></a>自适应</h4><p>自适应在移动端要适配很多种机型，通常使用media+rem的方式实现，缺点是media有优先级，多个media优先级覆盖不好会导致失效，设备太多测试很难，不具备通用性。</p>
<ul>
<li>基本概念</li>
</ul>
<ol>
<li>CSS像素、设备像素、逻辑像素、设备像素比</li>
<li>viewport</li>
<li>rem</li>
</ol>
<ul>
<li>工作原理</li>
</ul>
<ol>
<li>利用viewport和设备像素比调整基准像素</li>
<li>利用px2rem自动转换css单位</li>
<li>利用viewport和设备像素比调整基准像素</li>
</ol>
<p>css像素= 逻辑像素<br>设备像素是物理像素跟硬件相关<br>设备像素比 = css像素/设备像素</p>
<p>viewport：移动设备浏览器上(也可能是一个app中的webview)用来显示网页的一块”画布”。<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;</code></p>
<ul>
<li>width：控制viewport的大小，可以指定一个值，如600或特殊的值。如device-width为设备的宽度(单位为缩放100%时CSS的像素)</li>
<li>height：和width相对应，指定高度。</li>
<li>inital-scale：初始缩放比例，即当页面第一次load的时候缩放比例。</li>
<li>maximum-scale：允许用户缩放到的最大比例</li>
<li>minimum-scale：允许用户缩放的最小比例</li>
<li>user-scalable：用户是否可以手动缩放。</li>
</ul>
<p>with=device-width就是将layout裁剪成visual<br>ideal viewport的宽度 = 屏幕的逻辑像素宽度</p>
<p>viewport分三类：</p>
<ol>
<li>visual viewport: 可视视口(手机宽高内看到的画面)</li>
<li>layout viewport: 布局视口</li>
<li>ideal viewport: 理想窗口</li>
</ol>
<p>rem：rem是根据html的font-size大小变化。基于这个，可以在每一个设备下根据设备的宽度设置对应的html字号，从而实现自适应布局。<br>在vue中配置px2rem-loader，在开发时只使用px，px2rem把px转化成rem，再动态的计算font-size。</p>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><h4 id="模块化的使用和编译环境"><a href="#模块化的使用和编译环境" class="headerlink" title="模块化的使用和编译环境"></a>模块化的使用和编译环境</h4><h5 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h5><p>ES6模块设计思想是尽量静态化，这样在编译时就能确定模块的依赖关系。<br>语法：import export<br>输出：export default {}<br>引入：import xx from ‘路径’<br>环境： babel编译ES6语法</p>
<h5 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h5><p>将ES6现在浏览器还不支持的标准使用babel转化成ES5的语法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//babelrc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [&quot;env&quot;, &#123;</span><br><span class="line">      &quot;modules&quot;: false,</span><br><span class="line">      &quot;targets&quot;: &#123;</span><br><span class="line">        &quot;browsers&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    &quot;stage-2&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [&quot;transform-runtime&quot;],</span><br><span class="line">  &quot;env&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &#123;</span><br><span class="line">      &quot;presets&quot;: [&quot;env&quot;, &quot;stage-2&quot;],</span><br><span class="line">      &quot;plugins&quot;: [&quot;istanbul&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h5><p>开发环境-webpack</p>
<ol>
<li>npm init</li>
<li>npm install webpack babel-loader –save-dev</li>
<li><p>配置 webpack.config.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    //配置入口</span><br><span class="line">    entry: &apos;./src/index.js&apos;,</span><br><span class="line">    //配置输出</span><br><span class="line">    output: &#123;</span><br><span class="line">        path:__dirname,</span><br><span class="line">        filename: &apos;./build/build.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    //配置loader</span><br><span class="line">    module: &#123;</span><br><span class="line">        //规则</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            //监听所有的js文件</span><br><span class="line">            test: /\.js?$/,</span><br><span class="line">            //除了第三方的js文件</span><br><span class="line">            exclude: /(node_modules)/,</span><br><span class="line">            //使用babel编译</span><br><span class="line">            loader: &apos;babel-loader&apos;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    //配置插件</span><br><span class="line">    plugins,</span><br><span class="line">    //查询文件</span><br><span class="line">    resolve,</span><br><span class="line">    //开启服务</span><br><span class="line">    devServer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 package.json中的scripts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;webpack-dev-server --open&quot; //open会帮你启动的时候自动帮你打开页面</span><br><span class="line">    &quot;build&quot;: &quot;webpack --env.production&quot;  //打包输出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行 npm start</p>
</li>
</ol>
<h5 id="rollup"><a href="#rollup" class="headerlink" title="rollup"></a>rollup</h5><p>开发环境-rollup<br>rollup打包后内容会很小，如Vue的源代码就是使用rollup打包。<br>rollup功能单一，就是打包模块化，webpack功能强大。</p>
<ol>
<li>npm init</li>
<li>npm install rollup rollup-plugin-node-resolve rollup-plugin-babel babel-plugin-external-helpers babel-preset-latest –save-dev</li>
<li>配置 .babelrc</li>
<li><p>配置 rollup.config.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import babel from &apos;rollup-plugin-babel&apos;</span><br><span class="line">import resolve from &apos;rollup-plugin-node-resolve&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    entry: &apos;src/index.js&apos;,</span><br><span class="line">    //格式umd，兼容COMMONJS和AMDJS规范</span><br><span class="line">    format: &apos;umd&apos;,</span><br><span class="line">    //插件</span><br><span class="line">    plugins: [</span><br><span class="line">        resolve(),</span><br><span class="line">        babel(&#123;</span><br><span class="line">            exclude: &apos;node_modules/**&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    //输出</span><br><span class="line">    dest: &apos;build/build.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 package.json的scripts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    //将配置文件定位到rollup.config.js</span><br><span class="line">    &quot;start&quot;: &quot;rollup -c rollup.config.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行 npm start</p>
</li>
</ol>
<h5 id="模块化总结"><a href="#模块化总结" class="headerlink" title="模块化总结"></a>模块化总结</h5><ol>
<li>前端刚开始的时候是没有模块化的，写代码不规范。</li>
<li>之后有了一个前端工程化的体系，AMD成为标准，CMD标准(require.js)</li>
<li>后来前端打包工具出现，如gulp、webpack。nodejs模块化可以被使用。</li>
<li>ES6出现，出现了模块化，想统一现在所有模块化标准</li>
<li>nodejs积极支持模块化标准，但浏览器尚未统一。</li>
</ol>
<h5 id="nodejs模块化"><a href="#nodejs模块化" class="headerlink" title="nodejs模块化"></a>nodejs模块化</h5><p>exports与module.exports的区别<br>exports = add时，由于exports是引用值，改变了它的引用，将它和add的函数引用联系在一起。所以此时exports与module.exports无关，故最后reutrn的是module.exports还是一个空对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var modules = &#123;&#125;;</span><br><span class="line">modules.exportt = &#123;&#125;;</span><br><span class="line">var exportt  = modules.exportt;</span><br><span class="line">function add(a,b) &#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line">exportt = add;</span><br><span class="line">console.log(modules)</span><br></pre></td></tr></table></figure></p>
<h4 id="Class与JS构造函数的区别"><a href="#Class与JS构造函数的区别" class="headerlink" title="Class与JS构造函数的区别"></a>Class与JS构造函数的区别</h4><p><img src="/img/postImg/prototype.png" alt="prototype" title="prototype"></p>
<h5 id="定义一个构造函数"><a href="#定义一个构造函数" class="headerlink" title="定义一个构造函数"></a>定义一个构造函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function M(x,y) &#123;</span><br><span class="line">    this.x = x</span><br><span class="line">    this.y = y</span><br><span class="line">&#125;</span><br><span class="line">M.prototype.add = function() &#123;</span><br><span class="line">    return this.x + this.y</span><br><span class="line">&#125;</span><br><span class="line">var m = new M(1,2)</span><br><span class="line">m.add()</span><br></pre></td></tr></table></figure>
<h5 id="定义一个class"><a href="#定义一个class" class="headerlink" title="定义一个class"></a>定义一个class</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CM &#123;</span><br><span class="line">    constructor(x,y) &#123;</span><br><span class="line">        this.x = x</span><br><span class="line">        this.y = y</span><br><span class="line">    &#125;</span><br><span class="line">    add() &#123;</span><br><span class="line">        return this.x + this.y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const cm = new CM(1,2) //当new实例化CM时，有参数就会立即去查看M的constructor</span><br><span class="line">cm.add()</span><br></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>class就是es6推出了语法糖，1和2本质上没有区别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type CM //&quot;function&quot;</span><br><span class="line">CM === CM.prototype.constructor //true</span><br></pre></td></tr></table></figure></p>
<p>class为了后端开发者能更快适应JS，从形式上强行模仿 java和C#，但是因为JS里的实现与java和C#完全不一样，原理还是使用JS的原型实现，我认为这样其实更不利于后端开发者理解JS原型。<br>不过class在语法上更加贴合面向对象的写法，但本质上是语法糖，使用prototype。</p>
<h4 id="ES6其他常用功能"><a href="#ES6其他常用功能" class="headerlink" title="ES6其他常用功能"></a>ES6其他常用功能</h4><h5 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h5><h6 id="let"><a href="#let" class="headerlink" title="let"></a>let</h6><ol>
<li>用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</li>
<li>不存在变量提升现象，所以let声明的变量要在声明后使用。(var变量由于JS引擎预编译机制，变量在声明前可以使用，值为undefined)</li>
</ol>
<h6 id="const"><a href="#const" class="headerlink" title="const"></a>const</h6><ol>
<li>用来声明常量，因为const声明的变量的地址不能改变，故声明常量无法改变。但如果声明的是引用类型的变量如object，可以改变它的引用值。</li>
<li>const声明时要赋值，因为变量不能改变值，所以必须立即初始化。</li>
<li>不存在变量提升。</li>
</ol>
<h6 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h6><p>let和const之所以不变量提升，因为在这个let和const的区域内声明时就会形成封闭作用域。<br>在同一个作用域内，不能重复声明let，const变量,否则会报错。function，var在同一作用域重复声明变量，后者会覆盖前者，这是一种不安全的机制，所以在es6使用了这个规则。</p>
<p>原始值存储在栈中，变量可以直接访问 -&gt; 系统自动分配释放<br>引用值存储在堆中，值是一个指针，指向内存地址 -&gt; 动态分配内存空间，程序员可进行分配和释放（动态分配类似链表）</p>
<h5 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h5><p>使用{}形成一个封闭的作用域。<br>es6中块级作用域在es5中的实现：<br>由于是es6的东西，所以有很多浏览器以前的JS引擎不支持，所以出现了babel编译神器，需要将es6的代码编译成低版本的JS引擎的代码。babel的源码实现使用闭包和变量改变。</p>
<h5 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h5><p>模板字符串：<br>不在局限使用’’或者””,使用模板字符串可以在模板内任意写变量，变量使用${}，且能解析换行符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&lt;div&gt;welcome to $&#123;place&#125;&lt;/div&gt;`</span><br></pre></td></tr></table></figure></p>
<h5 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h5><p>在函数的参数里直接写上<code>function(a,b={}){}</code>。这不传b的值默认初始化为{}。<br>注意：默认参数要放在必选参数之后。</p>
<h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><p>v =&gt; v+1 就是箭头函数， 箭头左侧是函数的参数，当只有一个参数的时候可以不用 () ，等有多个参数的时候用 () 。箭头右侧是函数体，如何只有一行代码可以省略 {} 。</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><h4 id="什么是单线程，和异步有什么关系"><a href="#什么是单线程，和异步有什么关系" class="headerlink" title="什么是单线程，和异步有什么关系"></a>什么是单线程，和异步有什么关系</h4><p>单线程：只有一个线程，同一时间只能做一件事<br>原因：避免DOM渲染冲突<br>解决方案：异步<br>实现方式：event-loop</p>
<ul>
<li>为什么要单线程：浏览器需要渲染DOM，JS可以修改DOM结构。JS执行的时候，浏览器DOM渲染会停止，两段JS也不能同时执行修改DOM。</li>
<li>异步：异步操作可以让我们继续往下执行JS代码。异步任务会进入异步任务队列，等到异步任务完成，就会插入到同步队列中执行。</li>
</ul>
<h4 id="什么是event-loop-事件轮询"><a href="#什么是event-loop-事件轮询" class="headerlink" title="什么是event-loop(事件轮询)"></a>什么是event-loop(事件轮询)</h4><ol>
<li>同步代码，直接执行。</li>
<li>异步函数先放在异步队列中。</li>
<li>待同步函数执行完毕，轮询执行异步队列的函数。</li>
</ol>
<h4 id="如果只用jQuery如何解决异步"><a href="#如果只用jQuery如何解决异步" class="headerlink" title="如果只用jQuery如何解决异步"></a>如果只用jQuery如何解决异步</h4><p>使用jQuery.deferred处理异步。是jQuery1.5后引进的新方法。<br>jQuery.deferred初步引入Promise概念。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var ajax = $.ajax(&apos;data.json&apos;)</span><br><span class="line">ajax.then(function() &#123;</span><br><span class="line">    console.log(&apos;success1&apos;)</span><br><span class="line">&#125;, function() &#123;</span><br><span class="line">    console.log(&apos;error1&apos;)</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&apos;success2&apos;)</span><br><span class="line">&#125;, function() &#123;</span><br><span class="line">    console.log(&apos;error2&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>jQuery.deferred：无法改变JS异步和单线程的本质，只能从写法上杜绝callback的形式。它是一种语法糖，但解耦了代码。很好的体现了开放封闭原则。</p>
<h4 id="Promise的标准"><a href="#Promise的标准" class="headerlink" title="Promise的标准"></a>Promise的标准</h4><h5 id="使用回调函数加载图片"><a href="#使用回调函数加载图片" class="headerlink" title="使用回调函数加载图片"></a>使用回调函数加载图片</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function loadImg(src, callback, fail) &#123;</span><br><span class="line">    var img = document.createElement(&apos;img&apos;)</span><br><span class="line">    img.onload = function() &#123;</span><br><span class="line">        callback(img)</span><br><span class="line">    &#125;</span><br><span class="line">    img.onerror = function() &#123;</span><br><span class="line">        fail()</span><br><span class="line">    &#125;</span><br><span class="line">    img.src = src</span><br><span class="line">&#125;</span><br><span class="line">var src = &apos;https://github.com/wildBanana001/wildBanana001.github.io/tree/master/img/postImg/prototype.png&apos;</span><br><span class="line">loadImg(src, function(img) &#123;</span><br><span class="line">    console.log(img.width)</span><br><span class="line">&#125;, function() &#123;</span><br><span class="line">    console.log(&apos;failed&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="使用Promise加载图片"><a href="#使用Promise加载图片" class="headerlink" title="使用Promise加载图片"></a>使用Promise加载图片</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function loadImg(src) &#123;</span><br><span class="line">    const promise = new Promise(function (resolved, rejected) &#123;</span><br><span class="line">        var img = document.createElement(&apos;img&apos;)</span><br><span class="line">        img.onload = function() &#123;</span><br><span class="line">            resolved(img)</span><br><span class="line">        &#125;</span><br><span class="line">        img.onerror = function() &#123;</span><br><span class="line">            rejected()</span><br><span class="line">        &#125;</span><br><span class="line">        img.src = src</span><br><span class="line">    &#125;)</span><br><span class="line">    return promise</span><br><span class="line">&#125;</span><br><span class="line">var src = &apos;https://github.com/wildBanana001/wildBanana001.github.io/tree/master/img/postImg/prototype.png&apos;</span><br><span class="line">var result = loadImg(src)</span><br><span class="line">result.then(img =&gt; &#123;</span><br><span class="line">    console.log(img.width)</span><br><span class="line">&#125;, () =&gt; &#123;</span><br><span class="line">    console.log(&apos;failed&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>在JS中，所有的代码都是单线程执行的，所以JS的所有网络操作，浏览器事件都必须异步执行。而异步需要大量回调函数会导致页面结构混乱，形成可怕的回调地狱。<br>而ES6的Promise就是一个语法糖，帮助我们规范化书写回调函数。（采用链式调用的方法异步执行JS）<br>Promise对象有三个状体：<br>Pending（起始状体，进行中）<br>fulfilled/Resolved（成功）<br>Rejected（失败）<br>Pending –&gt; Resolved 或 Pending –&gt; Rejected<br>状体改变后不会在变。Promise实例必须实现then方法。then返回必须是一个Promise实例，因为这样才能继续链式then操作。</p>
<ul>
<li>Promise 对象：var promise = new Promise(function(resolved,rejected){});</li>
<li>Promise.catch：如果promise.then不传第二个参数，可以用promise.catch方法来获取promise对象失败时传来的数据，是rejected的语法糖。</li>
<li>Promise.all：Promise.all接收一个Promise对象的数组，待全部完成后，统一执行success。</li>
<li>Promise.race：Promise.race接收一个包含多个Promise对象的数组，只要有一个完成，就执行success。</li>
<li>特点：无等待。Promise实例会立即执行，返回一个Promise对象，并且不会阻塞后面的语句。</li>
</ul>
<h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><ul>
<li>then只是将callback拆分了。</li>
<li>async/await是最直接的同步写法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const load = async function &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        const result1 = await loadImg(src1)</span><br><span class="line">        console.log(result1)</span><br><span class="line">        const result2 = await loadImg(src2)</span><br><span class="line">        console.log(result2)</span><br><span class="line">    &#125; catch(err) &#123;</span><br><span class="line">        console.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">load()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意点：</p>
<ol>
<li>使用await，函数必须用async标识为异步函数。async标识会将函数的返回值封装成Promise对象。</li>
<li>await后面跟的是一个Promise实例。await会等待这个Promise完成，将resolved结果返回。错误可以使用try/catch来捕获。</li>
<li>需要babel-polyfill，因为是ES7的提案，还不是一个标准，现在各大浏览器并不支持。</li>
<li>再也没有回调函数了。Promise通过then链解决多层回调问题，而async/await进一步优化回调，几乎和同步代码一样。</li>
</ol>
<h3 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h3><h4 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h4><p>new Vue()<br>-&gt; Init(Event &amp; Lifecycle)<br>-&gt; beforeCreate -&gt; init(injections &amp; reactivity)<br>-&gt; created<br>-&gt; Has ‘el’ option? ( -N&gt; when vm.$mount(el) is called -&gt; )<br>-Y&gt;  Has ‘template’ options  ( -N&gt; Compile el’s outerHTML as template <em> ) (-Y&gt; Compile template into render funcrion </em> )<br>-&gt; beforeMount<br>-&gt; Create vm.$el and replace ‘el’ with it<br>-&gt; mounted<br>-&gt; Mounted (-&gt; when data changes -&gt; beforeUpdate -OR&gt; updated -&gt; Virtual Dom re-render and patch)<br>-&gt; when vm.$destroy() is called<br>-&gt; beforeDestroy<br>-&gt; Teardown watchers, child components and event listeners<br>-&gt; Destroyed<br>-&gt; destroyed</p>
<p>方法生命周期<br>beforeCreate<br>-&gt; created<br>-&gt; beforeMount<br>-&gt; mounted<br>-&gt; ( beforeUpdate -OR&gt; updated)<br>-&gt; beforeDestroy<br>-&gt; destroyed </p>
<p>创建Vue实例<br>-&gt; 初始化事件和生命周期，初始化_init是vue设置在prototype的私有属性，初始化时，_init里有一个属性是vm._uid，每次创建一个Vue实例时加1，以确保每一个Vue实例都是独一无二的。<br>-&gt;初始化注入和反应<br>-&gt; 是否有el属性，若无看是否使用$mount方法挂载，满足则进入下一个周期<br>-&gt; 是否有template模板属性<br>-&gt; 如果没有，则将挂载的el对象的外部HTML作为template模板，如果有则编译template模板进入render渲染函数<br>-&gt; 创建虚拟el替代Vue实例里的el<br>-&gt; （在更新前当数据发生变化 或者 更新 则触发虚拟DOM进行重新渲染re-render 和 产生补丁patch)<br>-&gt; 开始销毁虚拟Vue<br>-&gt; 卸载watchers, child, components 和 eventlisteners<br>-&gt; 销毁，结束</p>
<p>实现流程</p>
<ol>
<li>解析模板成render函数</li>
<li>响应式开始监听</li>
<li>首次渲染，显示页面，绑定依赖：<ul>
<li>初次渲染，執行updateComponent，執行vm.<em>render()</em></li>
<li>执行render函数，访问到vm.list和vm.title</li>
<li>被响应式的get方法监听到</li>
<li>执行updateComponent，会走到vdom的patch方法</li>
<li>patch将vnode渲染成DOM，初次渲染完成</li>
</ul>
</li>
<li>data属性变化，触发rerender</li>
</ol>
<h4 id="jquery和Vue的使用区别"><a href="#jquery和Vue的使用区别" class="headerlink" title="jquery和Vue的使用区别"></a>jquery和Vue的使用区别</h4><p>jQuery: 数据和视图的混合,使用DOM操作视图。<br>Vue： 数据和视图的分离,解耦(开放封闭原则：扩展开放，修改封闭)。以数据驱动视图，只关心数据变化，封装DOM操作。</p>
<h4 id="如何理解MVVM"><a href="#如何理解MVVM" class="headerlink" title="如何理解MVVM"></a>如何理解MVVM</h4><p>目的：双向数据绑定。<br>示例： Vue.js React.js Angular.js<br>M: Model &lt;=&gt; VM:viewModel &lt;=&gt; V:View<br>双向数据绑定：view(视图层) &lt;=&gt; data(数据层)<br>核心： Oject.defineProperty(),可以直接在一个对象上定义一个新属性或者修改属性。<br>    参数： obj: 定义属性的对象。 prop： 定义或修改属性的名称。 descriptor：定义或修改属性描述符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">descriptor: &#123;</span><br><span class="line">    configurable: true, //true时属性描述符才能改变，默认false</span><br><span class="line">    enumerable: true, //true时该属性才能枚举，默认false</span><br><span class="line">    value: &apos;&apos;,     //设置该对象对象的值，默认undefined</span><br><span class="line">    writable: true,  //true时该属性才能被赋值运算符改变，默认为false</span><br><span class="line">    get,</span><br><span class="line">    set</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用的设计模式：观察者模式。</p>
<p>问题：Object.defineProperty与reflect.defineProperty的区别？<br>Object.defineProperty是ES5的API，返回的是一个对象。<br>reflect.defineProperty是ES6的API，返回的是一个布尔值。</p>
<h4 id="Vue如何实现响应式-双向数据绑定"><a href="#Vue如何实现响应式-双向数据绑定" class="headerlink" title="Vue如何实现响应式 (双向数据绑定)"></a>Vue如何实现响应式 (双向数据绑定)</h4><p>核心API：Object.defineProperty</p>
<p>每当 new 一个 Vue，主要做了两件事：<br>第一个是监听数据：observer(data)，<br>第二个是编译 HTML：nodeToFragement(id)。<br>在监听数据的过程中，observer会为 data 中的每一个属性生成一个主题对象 Dep。<br>在编译 HTML 的过程中，会为每个与数据绑定相关的节点生成一个订阅者 watcher，watcher 会将自己添加到相应属性的 dep 中。<br>Watcher(观察者)会订阅Dep对象，然后数据改变后，Dep对象会通知所有的Watcher,Watcher就会去更新View。<br>修改输入框内容 =&gt; 在事件回调函数中修改属性值 =&gt; 触发属性的 set 方法。<br>发出通知 dep.notify() =&gt; 触发订阅者的 update 方法 =&gt; 更新视图。</p>
<h4 id="Vue模板-render函数"><a href="#Vue模板-render函数" class="headerlink" title="Vue模板 render函数"></a>Vue模板 render函数</h4><p>本质：字符串，有逻辑，可以嵌入JS变量。最终要转化为html显示。<br>render函数： 内部使用了with函数，可以改变作用域。将width内的属性的作用域改变为参数里的作用域。实际开发不推荐使用with，容易造成逻辑混乱等。</p>
<ol>
<li>模板中所有信息都被render函数包含。</li>
<li>模板中用到的data中的属性都变成了JS变量。</li>
<li>模板中的v-model v-for v-on都变成JS逻辑。</li>
<li>render函数执行返回vnode。</li>
</ol>
<h4 id="Vue的安装包有几个版本，遇到问题如何解决？"><a href="#Vue的安装包有几个版本，遇到问题如何解决？" class="headerlink" title="Vue的安装包有几个版本，遇到问题如何解决？"></a>Vue的安装包有几个版本，遇到问题如何解决？</h4><p><img src="/img/postImg/VueVersion.png" alt="VueVersion" title="VueVersion"><br>完整版：同时包含编译器和运行时的版本。<br>编译器：用来将模板字符串编译成JS渲染函数的代码。<br>运行时：用来创建Vue实例、渲染并处理虚拟DOM等的代码。基本上就是除去编译器的其他一切。</p>
<p>在webpack中引入vue.esm.js：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">        &apos;vue$&apos;:&apos;vue/dist/vue.esm.js&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="什么是vdom，为何使用vdom"><a href="#什么是vdom，为何使用vdom" class="headerlink" title="什么是vdom，为何使用vdom"></a>什么是vdom，为何使用vdom</h4><ul>
<li>virtual dom: 虚拟DOM</li>
<li>用JS模拟DOM结构</li>
<li>DOM变化的对比，放在JS层来做</li>
<li><p>提高重绘(repaint)性能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//真实DOM</span><br><span class="line">&lt;ul id=&apos;list&apos;&gt;</span><br><span class="line">    &lt;li class=&quot;item&quot;&gt;Item1&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;item&quot;&gt;Item2&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">//vdom</span><br><span class="line">&#123;</span><br><span class="line">    tag: &apos;ul&apos;,</span><br><span class="line">    attrs: &#123;</span><br><span class="line">        id: &apos;list&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    children: [</span><br><span class="line">        &#123;</span><br><span class="line">            tag: &apos;li&apos;,</span><br><span class="line">            attrs: &#123; className: &apos;item&apos; &#125;,</span><br><span class="line">            children: [&apos;Item1&apos;]</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            tag: &apos;li&apos;,</span><br><span class="line">            attrs: &#123; className: &apos;item&apos; &#125;,</span><br><span class="line">            children: [&apos;Item2&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DOM操作非常非常慢，而JS运行效率高</p>
</li>
<li>尽量减少DOM操作，而不是大幅度改动DOM</li>
<li>项目越复杂，影响越严重</li>
<li>vdom即可解决这个问题</li>
</ul>
<h4 id="vdom如何使用，核心函数有哪些"><a href="#vdom如何使用，核心函数有哪些" class="headerlink" title="vdom如何使用，核心函数有哪些"></a>vdom如何使用，核心函数有哪些</h4><p>vdom开源库：snabbdom等等<br>vnode = h //h函数生成虚拟dom结构<br>patch(container, vnode) //初次渲染则将vnode放入一个空白的容器进行渲染。<br>patch(vnode, newVnode) //对比新老节点，查看是否发生变化。再对变化的部分进行渲染。</p>
<h4 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h4><p>diff算法可以找出两个文本文件的区别。如我们可以用diff算法管理我们的代码库，修改后会告诉我们那里发生了改变。</p>
<p>vdom使用diff算法原因：</p>
<ol>
<li>DOM操作很慢，因此需要尽量减少DOM操作</li>
<li>找出本次DOM必须更新的节点来更新，其他的不更新</li>
<li>“找出”过程需要diff算法</li>
</ol>
<p>diff算法实现过程</p>
<ol>
<li>patch(container, vnode)：核心createElement</li>
<li>patch(vnode, newVnode):核心updateChildren<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//伪代码,创建真实DOM流程 patch(container, vnode)</span><br><span class="line">function createElement(vnode) &#123;</span><br><span class="line">    var tag = vnode.tag</span><br><span class="line">    var attrs = vnode.attrs || &#123;&#125;</span><br><span class="line">    var children = vnode.children || &#123;&#125;</span><br><span class="line">    if(!tag) &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line">    //创建元素</span><br><span class="line">    var elem = document.createElement(tag)</span><br><span class="line">    //属性</span><br><span class="line">    var attrName</span><br><span class="line">    for(attrName in attrs) &#123;</span><br><span class="line">        if(attes.hasOwnProperty(attrName)) &#123;</span><br><span class="line">            //给elem添加属性</span><br><span class="line">            elem.setAttribute(attrName, attrs[attrName])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    //子元素</span><br><span class="line">    children.forEach(function(childVnode) &#123;</span><br><span class="line">        //给elem添加子元素</span><br><span class="line">        elem.appendChild(createElement(childVnode)) //递归</span><br><span class="line">    &#125;)</span><br><span class="line">    //返回真实的dom元素</span><br><span class="line">    return elem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//伪代码，实现更新 patch(vnode, newVnode)</span><br><span class="line">function updateChildren(vnode, newVnode) &#123;</span><br><span class="line">    var children = vnode.children || []</span><br><span class="line">    var newChildren = newVnode.children || []</span><br><span class="line">    //遍历现有的children</span><br><span class="line">    children.forEach(function(child, index) &#123;</span><br><span class="line">        var newChild = newChildren[index]</span><br><span class="line">        if(newChild === null) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        if(child.tag === newChild.tag) &#123;</span><br><span class="line">            //两者tag一样，递归</span><br><span class="line">            updateChildren(child, newChild)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //两者tag不一样，替换</span><br><span class="line">            replaceNode(child, newChild)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function replaceNode(vnode, newVnode) &#123;</span><br><span class="line">    var elem = vnode.elem</span><br><span class="line">    var newElem = createElement(newVnode)</span><br><span class="line">    //替换操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>因为不知道vdom结构到底有几层，所以使用递归，进行循环。</p>
<h4 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h4><p>SPA设计：单页面设计</p>
<ol>
<li>设计意义</li>
</ol>
<ul>
<li>前后端分离</li>
<li>减轻服务器压力</li>
<li>增强用户体验</li>
<li>Prerender预渲染优化SEO</li>
</ul>
<ol>
<li>工作原理</li>
</ol>
<ul>
<li>History API(优雅): pushstate(创建一个历史记录)、onpopstate(响应前进、后退、控制事件)</li>
<li>hash(兼容性最好): location.hash(点击入口修改hash值)、hashchange(监听hash的修改)</li>
</ul>
<p>history是window下的属性。</p>
<h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br>vuex的目的是去管理非亲自组件之间的共享状态，如果父子组件可以使用props、slot插槽等设计来实现，对于非父子组件也可以使用事件总线方式来实现。<br>禁止vuex用来存储数据，组件的data才是用来存储数据的方法，用vuex来会让问题变得复杂。</p>
<h3 id="hybrid"><a href="#hybrid" class="headerlink" title="hybrid"></a>hybrid</h3><h4 id="hybrid是什么？"><a href="#hybrid是什么？" class="headerlink" title="hybrid是什么？"></a>hybrid是什么？</h4><h4 id="hybrid如何更新上线"><a href="#hybrid如何更新上线" class="headerlink" title="hybrid如何更新上线"></a>hybrid如何更新上线</h4><h4 id="hybrid与h5的区别"><a href="#hybrid与h5的区别" class="headerlink" title="hybrid与h5的区别"></a>hybrid与h5的区别</h4><h4 id="JS如何与客户端通信"><a href="#JS如何与客户端通信" class="headerlink" title="JS如何与客户端通信"></a>JS如何与客户端通信</h4><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>面试准备： 梳理历史项目、打造一个满意的项目、问答设计、更多思考。<br>项目介绍： 项目背景、项目收益、项目设计、项目总结。<br>沟通技巧： 强逻辑、谦虚、知进退、善总结。</p>
<h4 id="项目还能怎么改进？"><a href="#项目还能怎么改进？" class="headerlink" title="项目还能怎么改进？"></a>项目还能怎么改进？</h4><p>gzip压缩，vue异步加载了解一下。</p>
<h3 id="一些面试题"><a href="#一些面试题" class="headerlink" title="一些面试题"></a>一些面试题</h3><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>考查：函数和类、原型链、运算符优先级、作用域、变量提升<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    getName = function() &#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = function() &#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.getName = function() &#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">&#125;</span><br><span class="line">var getName = function() &#123;</span><br><span class="line">    console.log(4)</span><br><span class="line">&#125;</span><br><span class="line">function getName() &#123;</span><br><span class="line">    console.log(5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.getName()                   //2 相当于Foo.getName = function() &#123;&#125;函数运行</span><br><span class="line">getName()                       //4 变量提升，var声明的getName值为undefined，而函数是JS的第一公民，它会第一时间赋值，JS是单线程，所以运行到var的getName这时候又进行了赋值，到function时，已经赋值过所以不会重新赋值，故打印出的是4而不是5。</span><br><span class="line">Foo().getName()                 //1 这时候调用了function Foo()里的getName，然后return this，由于是在全局下调用，这个this指向window，所以会将getName重新赋值。</span><br><span class="line">getName()                       //1 此时调用的getName已被上一个覆盖。getName() = this.getName = window.getName</span><br><span class="line">new Foo.getName()               //2 new Foo.getName() = new function()&#123; console.log(2) &#125;</span><br><span class="line">new Foo().getName()             //3 new了Foo()实例，访问的是Foo原型上的方法getName</span><br><span class="line">new new Foo().getName()         //3 new Foo().getName优先级比new高，所以先执行new Foo().getName()。所以最后还是3。</span><br></pre></td></tr></table></figure></p>
<p>运算符优先级：<br><img src="/img/postImg/operatorPriority1.png" alt="operatorPriority1" title="operatorPriority1"><br><img src="/img/postImg/operatorPriority2.png" alt="operatorPriority2" title="operatorPriority2"><br><img src="/img/postImg/operatorPriority3.png" alt="operatorPriority3" title="operatorPriority3"></p>
<h3 id="使用面向对象的方式维护一个列表，每个列表有一个删除按钮，点击删除移除当前行"><a href="#使用面向对象的方式维护一个列表，每个列表有一个删除按钮，点击删除移除当前行" class="headerlink" title="使用面向对象的方式维护一个列表，每个列表有一个删除按钮，点击删除移除当前行"></a>使用面向对象的方式维护一个列表，每个列表有一个删除按钮，点击删除移除当前行</h3><p>考查：复用性设计、事件代理、事件绑定、渲染机制、递归<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class List &#123;</span><br><span class="line">    constructor(sel) &#123;</span><br><span class="line">        this.el = Array.from(document.querySelectorAll(sel))</span><br><span class="line">        let self = this</span><br><span class="line">        this.el.forEach(item =&gt; &#123;</span><br><span class="line">            item.addEventListener(&apos;click&apos;, function(e) &#123;</span><br><span class="line">                if(e.target.className.indexOf(&apos;del&apos;) &gt; -1) &#123;</span><br><span class="line">                    self.removeItem.call(self, e.target)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    removeItem(target) &#123;</span><br><span class="line">        let self = this</span><br><span class="line">        let findParent = function(node) &#123;</span><br><span class="line">            let parent = node.parentNode</span><br><span class="line">            let root = self.el.find(item =&gt; item === parent)</span><br><span class="line">            if(root) &#123;</span><br><span class="line">                root.removeChild(node)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                findParent(parent)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        findParent(target)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.addEventListener(&apos;DOMContentLoaded&apos;, function() &#123;</span><br><span class="line">    new List(&apos;.list&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>思路：在构造函数中，只查找DOM元素和绑定事件，处理方法则解耦出来，方便后期扩展和维护。使用事件委托，避免事件性能问题。使用递归收集是哪个发出的响应，然后执行方法。最后监听DOMContentLoaded，等到代码结构渲染出来，在创建实例。</p>
<h3 id="输出顺序"><a href="#输出顺序" class="headerlink" title="输出顺序"></a>输出顺序</h3><p>考查：async/await、事件队列、宏任务/微任务、Promise、setTimeout<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">    console.log(&apos;async1 start&apos;)</span><br><span class="line">    await async2()</span><br><span class="line">    console.log(&apos;async1 end&apos;)</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">    console.log(&apos;async2 start&apos;)</span><br><span class="line">    await async3()</span><br><span class="line">    console.log(&apos;async2 end&apos;)</span><br><span class="line">&#125;</span><br><span class="line">async function async3() &#123;</span><br><span class="line">    console.log(&apos;async3&apos;)</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;)</span><br><span class="line">&#125;,0)</span><br><span class="line">console.log(&apos;start&apos;)</span><br><span class="line">async1()</span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&apos;P1&apos;)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;P2&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;end&apos;)</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">start</span><br><span class="line">async1 start</span><br><span class="line">async2 start</span><br><span class="line">async3</span><br><span class="line">P1</span><br><span class="line">end</span><br><span class="line">P2</span><br><span class="line">async2 end</span><br><span class="line">async1 end</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure></p>

            
        </div>
    
</div>


                
                    <!-- Paradox Post Info -->
                    
                

                <!-- Post Comments -->
                
                    
                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2018/06/03/计算机基础/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Neuren
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2018/05/03/前端性能优化/" id="post_nav-older" class="next-content">
            Älteren
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?V/53wGualMuiPM3xoetD5Q==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>













<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.2 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
