<!DOCTYPE html>
<html style="display: none;" >
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.2 -->
    <script>
        window.materialVersion = "1.5.2"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1',
            '1.5.0'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">














    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!-- Title -->
    
    <title>
        
            web前端面试知识点总结 | 
        
        BLOG
    </title>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">

    <meta name="format-detection" content="telephone=no"/>
    <meta name="description" itemprop="description" content="">
    <meta name="keywords" content=",html css js jQuery 网络 性能优化 webpack vue">
    <meta name="theme-color" content="#0097A7">

    <!-- Disable Fucking Bloody Baidu Tranformation -->
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.en.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(a){try{localStorage.removeItem(a)}catch(b){}};lsloader.setLS=function(a,c){try{localStorage.setItem(a,c)}catch(b){}};lsloader.getLS=function(a){var c="";try{c=localStorage.getItem(a)}catch(b){c=""}return c};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var b=[];for(var a=0;a<localStorage.length;a++){b.push(localStorage.key(a))}b.forEach(function(e){var f=lsloader.getLS(e);if(window.oldVersion){var d=window.oldVersion.reduce(function(g,h){return g||f.indexOf("/*"+h+"*/")!==-1},false);if(d){lsloader.removeLS(e)}}})}catch(c){}};lsloader.clean();lsloader.load=function(f,a,b,d){if(typeof b==="boolean"){d=b;b=undefined}d=d||false;b=b||function(){};var e;e=this.getLS(f);if(e&&e.indexOf(versionString)===-1){this.removeLS(f);this.requestResource(f,a,b,d);return}if(e){var c=e.split(versionString)[0];if(c!=a){console.log("reload:"+a);this.removeLS(f);this.requestResource(f,a,b,d);return}e=e.split(versionString)[1];if(d){this.jsRunSequence.push({name:f,code:e});this.runjs(a,f,e)}else{document.getElementById(f).appendChild(document.createTextNode(e));b()}}else{this.requestResource(f,a,b,d)}};lsloader.requestResource=function(b,e,a,c){var d=this;if(c){this.iojs(e,b,function(h,f,g){d.setLS(f,h+versionString+g);d.runjs(h,f,g)})}else{this.iocss(e,b,function(f){document.getElementById(b).appendChild(document.createTextNode(f));d.setLS(b,e+versionString+f)},a)}};lsloader.iojs=function(d,b,g){var a=this;a.jsRunSequence.push({name:b,code:""});try{var f=new XMLHttpRequest();f.open("get",d,true);f.onreadystatechange=function(){if(f.readyState==4){if((f.status>=200&&f.status<300)||f.status==304){if(f.response!=""){g(d,b,f.response);return}}a.jsfallback(d,b)}};f.send(null)}catch(c){a.jsfallback(d,b)}};lsloader.iocss=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.iofonts=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.runjs=function(f,c,e){if(!!c&&!!e){for(var b in this.jsRunSequence){if(this.jsRunSequence[b].name==c){this.jsRunSequence[b].code=e}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var a=document.createElement("script");a.appendChild(document.createTextNode(this.jsRunSequence[0].code));a.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(a);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else{if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var d=this;var a=document.createElement("script");a.src=this.jsRunSequence[0].path;a.type="text/javascript";this.jsRunSequence[0].status="loading";a.onload=function(){d.jsRunSequence.shift();if(d.jsRunSequence.length>0){d.runjs()}};document.body.appendChild(a)}}};lsloader.tagLoad=function(b,a){this.jsRunSequence.push({name:a,code:"",path:b,status:"failed"});this.runjs()};lsloader.jsfallback=function(c,b){if(!!this.jsnamemap[b]){return}else{this.jsnamemap[b]=b}for(var a in this.jsRunSequence){if(this.jsRunSequence[a].name==b){this.jsRunSequence[a].code="";this.jsRunSequence[a].status="failed";this.jsRunSequence[a].path=c}}this.runjs()};lsloader.cssfallback=function(e,c,b){if(!!this.cssnamemap[c]){return}else{this.cssnamemap[c]=1}var d=document.createElement("link");d.type="text/css";d.href=e;d.rel="stylesheet";d.onload=d.onerror=b;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(d,a)};lsloader.runInlineScript=function(c,b){var a=document.getElementById(b).innerText;this.jsRunSequence.push({name:c,code:a});this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?MKetZV3cUTfDxvMffaOezg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        

    

    
        
            <link rel="stylesheet" href="/css/fontawesome.min.css">
        
    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-image: url(/img/bg.png);
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icons -->


    <style id="material_icons"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_icons","/css/material-icons.css?pqhB/Rd/ab0H2+kZp0RDmw==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==", true)</script>
    

    <!-- WebAPP Icons -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="BLOG">
    <meta name="msapplication-starturl" content="http://yoursite.com/2018/04/21/面试知识点总结/">
    <meta name="msapplication-navbutton-color" content="#0097A7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="BLOG">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://yoursite.com/2018/04/21/面试知识点总结/">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="web前端面试知识点总结 | BLOG">
    <meta property="og:image" content="/img/favicon.png">
    <meta property="og:description" content="">
    <meta property="og:article:tag" content="html css js jQuery 网络 性能优化 webpack vue"> 

    
        <meta property="article:published_time" content="Sat Apr 21 2018 23:23:59 GMT+0800">
        <meta property="article:modified_time" content="Tue May 15 2018 03:11:17 GMT+0800">
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:card" content="summary_large_image">

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://yoursite.com/2018/04/21/面试知识点总结/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://yoursite.com/2018/04/21/面试知识点总结/index.html",
    "headline": "web前端面试知识点总结",
    "datePublished": "Sat Apr 21 2018 23:23:59 GMT+0800",
    "dateModified": "Tue May 15 2018 03:11:17 GMT+0800",
    "author": {
        "@type": "Person",
        "name": "林凯锋",
        "image": {
            "@type": "ImageObject",
            "url": "/img/myavatar.png"
        },
        "description": "github.com/wildBanana001"
    },
    "publisher": {
        "@type": "Organization",
        "name": "BLOG",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/favicon.png"
        }
    },
    "keywords": ",html css js jQuery 网络 性能优化 webpack vue",
    "description": "",
}
</script>


    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head -->
    

</head>


    
        <body id="scheme-Isolation" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                
                    <!-- Isolation Header -->
                    <header class="header">
    <div class="header-wrapper">
        <!-- Header Copyright -->
        <div class="header-copyright">
            <div class="header-site">
                ©&nbsp;
                <script type="text/javascript">
                    var fd = new Date();
                    document.write(fd.getFullYear());
                </script>
                &nbsp;BLOG
            </div>
            <!--
            I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright.
            It will not impact the appearance and can give developers a lot of support :)

            很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
            它不会影响美观并可以给开发者很大的支持。 :)
            -->
            <div>
                Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a>
                <br>
                Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a>
            </div>
        </div>

        <!-- Header Title -->
        <span class="header-title header-item">
            <a href="/" title="BLOG">
                BLOG
            </a>
        </span>

        <p class="header-slogan header-item">
        
            
                github.com/wildBanana001
            
        
        </p>

        <!-- Header Nav -->
        <nav class="header-nav header-item">
            <span class="header-nav-item">
                <a href="/" title="Home">
                    <span>رئيسية</span>
                </a>
            </span>

            <!-- Pages  -->
            
            
        </nav>

        <!-- Header SNS -->
        <div class="header-item header-sns_list">
    <!-- Twitter -->
    
        <a href="https://twitter.com/twitter" target="_blank">
            <i class="fa fa-twitter fa-lg" aria-hidden="true"></i>
        </a>
    

    <!-- Facebook -->
    
        <a href="https://www.facebook.com/facebook" target="_blank">
            <i class="fa fa-facebook fa-lg" aria-hidden="true"></i>
        </a>
    

    <!-- Google + -->
    
        <a href="https://www.google.com/" target="_blank">
            <i class="fa fa-google-plus fa-lg" aria-hidden="true"></i>
        </a>
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    

    <!-- LinkedIn -->
    

    <!-- Telegram -->
    
</div>

    </div>
</header>

                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    

                    <!-- Post TOC -->

    



<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                


    <!-- Isolation Post Header -->
    <!-- Post thumbnail -->
    
        <!-- Post Header Info -->
        <div class="post-header_info without-thumbnail">
            <!-- Author Avatar & Name -->
            <img src="/img/myavatar.png" class="avatar-img" width="44px" height="44px" alt="林凯锋's avatar">
            <span class="name-span">林凯锋</span>
        </div>

        <!-- Null Thumbnail -->
        <div class="post_thumbnail-null">
    
        </div>



                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    

    
        <div class="post-content_wrapper">
            <p class="post-title">
                web前端面试知识点总结
            </p>
            <h2 id="面试常见知识点总结"><a href="#面试常见知识点总结" class="headerlink" title="面试常见知识点总结"></a>面试常见知识点总结</h2><h3 id="HTML与CSS部分"><a href="#HTML与CSS部分" class="headerlink" title="HTML与CSS部分"></a>HTML与CSS部分</h3><h4 id="什么是html语义化，为什么要语义化，有什么好处，怎么做？-待补充"><a href="#什么是html语义化，为什么要语义化，有什么好处，怎么做？-待补充" class="headerlink" title="什么是html语义化，为什么要语义化，有什么好处，怎么做？(待补充)"></a>什么是html语义化，为什么要语义化，有什么好处，怎么做？(待补充)</h4><h4 id="inline、block、inline-block"><a href="#inline、block、inline-block" class="headerlink" title="inline、block、inline-block"></a>inline、block、inline-block</h4><h4 id="padding和margin的单位设置为-时，这个-是相对于谁。"><a href="#padding和margin的单位设置为-时，这个-是相对于谁。" class="headerlink" title="padding和margin的单位设置为%时，这个%是相对于谁。"></a>padding和margin的单位设置为%时，这个%是相对于谁。</h4><h4 id="inline与inline-block元素间会有莫名的间距这个是怎么产生的，怎么解决。"><a href="#inline与inline-block元素间会有莫名的间距这个是怎么产生的，怎么解决。" class="headerlink" title="inline与inline-block元素间会有莫名的间距这个是怎么产生的，怎么解决。"></a>inline与inline-block元素间会有莫名的间距这个是怎么产生的，怎么解决。</h4><h4 id="去浮动"><a href="#去浮动" class="headerlink" title="去浮动"></a>去浮动</h4><ol>
<li><p>为带有浮动元素的父元素，添加伪元素（最佳推选）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:after &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    clear: both;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>触发bfc，为带有浮动元素的父元素，添加 <code>overflew：hidden</code></p>
</li>
<li>触发bfc，为带有浮动元素的父元素，添加 <code>position：absolute</code></li>
<li>触发bfc，为带有浮动元素的父元素，添加 <code>display：inline-block</code></li>
<li>触发bfc，为带有浮动元素的父元素，添加 <code>zoom：1 // _zoom: 1 ie6 // *zoom: 1 ie6 ie7</code></li>
</ol>
<h4 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h4><p>浏览器内核又可以分成两部分：渲染引擎和JS引擎。它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。<br>后来JS引擎独立，内核就倾向于只指渲染引擎。2013 年以前，代表有 Trident（IE），Gecko（firefox），Webkit（Safari chrome 等）以及 Presto（opera)。2013 年，谷歌开始研发 blink 引擎，chrome 28 以后开始使用，而 opera 则放弃了自主研发的 Presto 引擎，投入谷歌怀抱，和谷歌一起研发 blink 引擎，国内各种 chrome系的浏览器（360、UC、QQ、2345 等等）也纷纷放弃 webkit，投入 blink 的怀抱。</p>
<p>扩展： Webkit 其实是 KHTML 的分支，这里的 KHTML 指渲染引擎，Webkit 其实就泛指了 Webkit 的渲染引擎 WebCore，而 Webkit 引擎的 Javascript 引擎 JSCore 则是 KJS 的分支。而 chrome 则搭载了自己的 Javascript 引擎。</p>
<p>引用 各主流浏览器内核介绍 里的一段话：<br>    我们上面提到 Chrome 是基于 WebKit 的分支，而 WebKit 又由渲染引擎 “WebCore” 和 JS 解释引擎 “JSCore” 组成，可能会让你搞不清 V8 和 JSCore 的关系。你可以这样理解—— WebKit 是一块主板，JSCore 是一块可拆卸的内存条，谷歌实际上认为 Webkit 中的 JSCore 不够好，才自己搞了一个 V8 JS 引擎，这就是 Chrome 比 Safari 在某些 JS 测试中效率更高的原因。</p>
<h4 id="图片有哪几种格式？各自的优缺点是什么？png有哪些格式？各自的特点是什么？-待补充"><a href="#图片有哪几种格式？各自的优缺点是什么？png有哪些格式？各自的特点是什么？-待补充" class="headerlink" title="图片有哪几种格式？各自的优缺点是什么？png有哪些格式？各自的特点是什么？(待补充)"></a>图片有哪几种格式？各自的优缺点是什么？png有哪些格式？各自的特点是什么？(待补充)</h4><p>PNG8: 8位的png最多支持256(2^8)种颜色，8位的png其实支持不透明、索引透明、alpha透明。</p>
<h4 id="BFC（Block-Formatting-Context）"><a href="#BFC（Block-Formatting-Context）" class="headerlink" title="BFC（Block Formatting Context）"></a>BFC（Block Formatting Context）</h4><p>块级格式化上下文。<br>overflow : hidden<br>position: absolute 、fixed<br>display: inline-block 、table-cell 、table-caption<br>这些属性创建时会自动创建BFC。<br>新方式：只为创建BFC无任何副作用。 display: flow-root<br>BFC适用： 解决浮动问题、两栏布局、margin塌陷/合并</p>
<p>Flex(弹性)和 Grid(网格)布局中的元素也会自动创建类似BFC的机制，只是它们被称为 Flex Formatting Context(FFC,弹性格式上下文) 和 Grid Formatting Context(GFC,网格格式上下文)。</p>
<h4 id="css两栏布局实现方法"><a href="#css两栏布局实现方法" class="headerlink" title="css两栏布局实现方法"></a>css两栏布局实现方法</h4><ol>
<li>float + margin<br> 给左边的元素一个固定宽度，向左浮动，给右边一个向右浮动，宽度为100%，设置margin-left为120px（避免重合，且间距为20px）</li>
<li>float + BFC<br> 给左边的元素一个固定宽度，向左浮动，给右边一个overflow:hidden触发BFC特性。</li>
<li>absolute<br> 给父级一个position：relative。给左边position：absolute；left：0；及一个宽度。给右边position：absolute；right：0；left：120px;则可以实现自适应。</li>
<li>flex<br> 给父级设置display：flex。给自适应子级一个flex：1即可。</li>
</ol>
<h4 id="css垂直居中"><a href="#css垂直居中" class="headerlink" title="css垂直居中"></a>css垂直居中</h4><ol>
<li><p>absolute + margin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line">position:absolute;</span><br><span class="line">width:100px;</span><br><span class="line">height:100px;</span><br><span class="line">padding:10px;</span><br><span class="line">top:50%;</span><br><span class="line">left:50%;</span><br><span class="line">margin-left: -60px; /*(width+padding)/2*/</span><br><span class="line">margin-top: -60px; /*(height+padding)/2*/</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">方法二：(适用于绝大数情况)</span><br><span class="line">position:absolute;</span><br><span class="line">margin:auto;</span><br><span class="line">top:0;</span><br><span class="line">left:0;</span><br><span class="line">bottom:0;</span><br><span class="line">right:0;</span><br></pre></td></tr></table></figure>
</li>
<li><p>absolute + transform3d (ie8以下不适合)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">position: absolute;</span><br><span class="line">top: 50%; </span><br><span class="line">left: 50%;</span><br><span class="line">transform: translate(-50%,-50%);</span><br></pre></td></tr></table></figure>
</li>
<li><p>flex</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display: flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">align-items: center;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="css怪异盒模型与普通盒模型区别，在怪异盒模型中图片应该从哪一部分展开？"><a href="#css怪异盒模型与普通盒模型区别，在怪异盒模型中图片应该从哪一部分展开？" class="headerlink" title="css怪异盒模型与普通盒模型区别，在怪异盒模型中图片应该从哪一部分展开？"></a>css怪异盒模型与普通盒模型区别，在怪异盒模型中图片应该从哪一部分展开？</h4><p>以前HTML和CSS没有一个统一的标准，所以到后来出现统一标准后，要对老网页兼容，则出现了怪异模式。我们经常能看到HTML文档第一行有 &lt;!DOCTYPE html&gt;声明。说明这个页面遵守了HTML5规范的,浏览器会自动选择标准模式。</p>
<p>怪异盒模型：<br><code>box-sizing: border-box; // IE6混杂模式的盒模型 border + padding + content = 设置的宽／高(width: …px / height: …px)</code><br><code>所以 border-box 的总 宽／高 = content + margin</code></p>
<p>图片对其方式：<br>标准盒模型：verticle-align: baseline; (inline, tablecell)怪异盒模型：verticle-align: bottom; </p>
<h4 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h4><p>flex: 弹性容器(父元素) 、 弹性项目(子元素)<br>实则flex布局后，子元素的float、clear和vertical-align属性会失效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">弹性容器：</span><br><span class="line"></span><br><span class="line">flex-direction 定义排列的方向</span><br><span class="line">row 默认值，主轴为水平，从左向右排列</span><br><span class="line">row-reverse 主轴为水平，从右向左排列</span><br><span class="line">column 主轴为垂直方向，从上向下排列</span><br><span class="line">column-reverse 主轴为垂直方向，从下向上排列</span><br><span class="line"></span><br><span class="line">flex-wrap 定义是否新行显示，以及新行的排列方向</span><br><span class="line">nowrap 默认值，显示在同一行，不换行</span><br><span class="line">wrap 一行显示不了时使用新行显示</span><br><span class="line">wrap-reverse 同 wrap，但是从下向上显示</span><br><span class="line"></span><br><span class="line">flex-flow 是 flex-direction 和 flex-wrap 的简写方式使用方法 </span><br><span class="line">flex-flow: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt;</span><br><span class="line">默认值为： row nowrap</span><br><span class="line"></span><br><span class="line">justify-content 定义弹性项目在主轴上的对齐方式</span><br><span class="line">flex-start 默认值，从起始位置对齐，通常为左对齐</span><br><span class="line">flex-end 从结束位置对齐，通常为右对齐</span><br><span class="line">center 居中对齐</span><br><span class="line">space-between 两端对齐，平均间隔</span><br><span class="line">space-around 每个子元素都有相等的外边距，相邻元素外边距不会叠加</span><br><span class="line"></span><br><span class="line">align-items 定义弹性项目在侧轴上的对齐方式</span><br><span class="line">stretch 默认值，弹性项目在没指定高度或者高度为 auto 的情况下，则高度会占满空间</span><br><span class="line">flex-start 侧轴起点开始对齐</span><br><span class="line">flex-end 从侧轴结束位置对齐</span><br><span class="line">center 相对侧轴居中对齐</span><br><span class="line">baseline 与基线对齐</span><br><span class="line"></span><br><span class="line">align-content 定义多行在侧轴的对齐方式，当只有一行时，不起作用</span><br><span class="line">stretch 默认值，各行会伸展以占满整个纵轴空间</span><br><span class="line">flex-start 对齐到纵轴起点</span><br><span class="line">flex-end 对齐到纵轴终点</span><br><span class="line">center 相对纵轴中间对齐</span><br><span class="line">space-between 各行相对纵轴两端对齐，各行间隔相等</span><br><span class="line">space-around 各行都有相等的外边距，各行的外边距不会叠加</span><br><span class="line"></span><br><span class="line">弹性项目：</span><br><span class="line"></span><br><span class="line">flex-grow 数字，定义弹性项目的放大比例，默认 0</span><br><span class="line">flex-shrink 数字，定义弹性项目的缩小比例，默认 1，值 0 表示不缩小</span><br><span class="line">flex-basis 数字，定义弹性项目的默认尺寸，</span><br><span class="line">flex 是 flex-grow flex-shrink flex-basis 的缩写，默认值为 0 1 auto</span><br><span class="line">align-self 定义此弹性项目本身的对齐方式，会覆盖弹性容器 </span><br><span class="line">align-items 定义的对齐方式auto 从弹性容器继承</span><br><span class="line">stretch 弹性项目在没指定高度或者高度为 auto 的情况下，则高度会占满空间</span><br><span class="line">flex-start 侧轴起点开始对齐</span><br><span class="line">flex-end 从侧轴结束位置对齐</span><br><span class="line">center 相对侧轴居中对齐</span><br><span class="line">baseline 与基线对齐</span><br><span class="line">order 数字，定义弹性项目的显示顺序，数字越小越靠前</span><br></pre></td></tr></table></figure>
<h3 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h3><h4 id="事件冒泡-捕获-委托-代理"><a href="#事件冒泡-捕获-委托-代理" class="headerlink" title="事件冒泡/捕获/委托(代理)"></a>事件冒泡/捕获/委托(代理)</h4><p>事件流：事件捕获阶段（从上到下） -&gt; 处于目标阶段 -&gt; 事件冒泡阶段（从下到上）</p>
<p>监听方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(event, function, useCapture)</span><br><span class="line">event：事件名，支持所有DOM事件</span><br><span class="line">function：指定事件触发时执行的函数</span><br><span class="line">useCapture（可选）：指定事件是否在捕获或冒泡阶段执行。</span><br><span class="line">true：捕获, false：冒泡。 默认false</span><br></pre></td></tr></table></figure></p>
<p>处于目标阶段时，没有捕获与冒泡之分，执行顺序按照addEventListener的添加顺序决定。<br>使用stopPropagation()取消事件传播时，事件不会被传播给下一个节点，但同一节点的其他listener还是会执行。</p>
<p>事件委托：利用事件冒泡，在所需DOM树最高层上添加一个事件处理程序。<br>适合事件委托事件： <code>click、mousedown、mouseup、keydown、keyup、keypress</code></p>
<p>阻止默认事件主流浏览器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">event.preventDefault();</span><br><span class="line">ie：event.returnValue = false;</span><br><span class="line">其他：return false;</span><br></pre></td></tr></table></figure></p>
<h4 id="跨浏览器的事件模型"><a href="#跨浏览器的事件模型" class="headerlink" title="跨浏览器的事件模型"></a>跨浏览器的事件模型</h4><p>主要是兼容性问题。</p>
<ol>
<li><p>事件处理程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var EventUtil = &#123; </span><br><span class="line">    addHandler:function(element,type,handler) &#123; </span><br><span class="line">        if(element.addEventListener) &#123;</span><br><span class="line">            //检测是否存在DOM2 </span><br><span class="line">            element.addEventListener(type,handler,false) </span><br><span class="line">        &#125; else if(element.attachEvent) &#123;</span><br><span class="line">            //存在ie </span><br><span class="line">            element.attachEvent(&apos;on&apos;+type,handler) </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //DOM0 </span><br><span class="line">            element[&apos;on&apos;+type]=handelr; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;, </span><br><span class="line">    removeHandler:function(element,type,handler) &#123; </span><br><span class="line">        if(element.removeEventListener) &#123; </span><br><span class="line">            element.removeEventListener(type,handler,false); </span><br><span class="line">        &#125; else if(element.detachEvent) &#123;</span><br><span class="line">            element.detachEvent(&apos;on&apos;+type,handler); </span><br><span class="line">        &#125;else &#123; </span><br><span class="line">            element[&apos;on&apos;+type]=null; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">var btn = document.getElementById(&apos;myBtn&apos;); </span><br><span class="line">var handler = function()&#123; </span><br><span class="line">    console.log(&apos;hi&apos;) </span><br><span class="line">&#125; </span><br><span class="line">EventUtil.addHandler(btn,&apos;click&apos;,handler); </span><br><span class="line">EventUtil.removeHandler(btn,&apos;click&apos;,handler);</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var EventUtil= &#123; </span><br><span class="line">    getEvent:function(event) &#123;</span><br><span class="line">        //事件对象 </span><br><span class="line">        return event ? event:window.event </span><br><span class="line">    &#125;, </span><br><span class="line">    getTarget:function(evet) &#123;</span><br><span class="line">        //事件目标 </span><br><span class="line">        return event.target || event.srcElement; </span><br><span class="line">    &#125;, </span><br><span class="line">    prventDefault:function(event) &#123;</span><br><span class="line">        //取消事件默认行为 </span><br><span class="line">        if(event.preventDefault) &#123; </span><br><span class="line">            event.preventDefault(); </span><br><span class="line">        &#125; else &#123; </span><br><span class="line">            event.returnValue=false; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;, </span><br><span class="line">    stopPropagation:function(event) &#123;</span><br><span class="line">        //取消事件进一步冒泡或捕获 </span><br><span class="line">        if(event.stopPropagation) &#123; </span><br><span class="line">            event.stopPropagation(); </span><br><span class="line">        &#125;else&#123; </span><br><span class="line">            event.cancelBubble=true; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">btn.onclick=function(event) &#123; </span><br><span class="line">    event = EventUtil.getEvent(event); </span><br><span class="line">    var target = EventUtil.getTarget(event) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>优点<br>避免占用全局变量名，保护全局环境。<br>匿名函数是一个独立的作用域，传参可以保护临时变量，组件化开发时将命名空间传递到函数中用闭包保护起来，即使命名空间被后面代码重叠，也会利用闭包保护内部生态。</p>
<p>缺点<br>没有名字，调试代码时报错，但无法说明其错误根源是什么。<br>匿名函数事件不能解绑。</p>
<h4 id="原始值和引用值"><a href="#原始值和引用值" class="headerlink" title="原始值和引用值"></a>原始值和引用值</h4><p>原始值：<br><code>Number、String、Boolean、undefined、null、Symbol（表示独一无二的值）</code><br>引用值：<br><code>Object（Array）、function、Date()、regEXP()</code><br>原始值存储在栈中，变量可以直接访问 -&gt; 系统自动分配释放<br>引用值存储在堆中，值是一个指针，指向内存地址 -&gt; 动态分配内存空间，程序员可进行分配和释放（动态分配类似链表）</p>
<h4 id="如何判断一个数组"><a href="#如何判断一个数组" class="headerlink" title="如何判断一个数组"></a>如何判断一个数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">Array.isArray(arr) === true;</span><br><span class="line">Object.prototype.toString.call(arr) === &apos;[object Array]&apos;;</span><br><span class="line">arr instanceof Array === true;</span><br><span class="line">arr.constructor === Array;</span><br><span class="line">arr.__proto__.constructor.name === &quot;Array&quot;</span><br></pre></td></tr></table></figure>
<h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><ol>
<li><p>遍历数组，建立新数组。利用indexOf判断是否存在在新数组中，不存在则push到新数组上，最后返回新数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    var newArr = [];</span><br><span class="line">    for(let i = 0,len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        if(newArr.indexOf(arr[i]) === -1 ) &#123;</span><br><span class="line">            newArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    return newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历数组，利用object对象保存数组值，判断数组值是否已经保存在object中，未保存则push到新数组并用object[arrayItem]=1的方式记录保存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//有缺陷,当数组中存放1和‘1’会默认去掉其中一个，从而达不到想要的效果</span><br><span class="line">function unique(arr) &#123;</span><br><span class="line">    var tmp = &#123;&#125;,</span><br><span class="line">        newArr = [];</span><br><span class="line">    for(let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        if(!tmp[arr[i]]) &#123;</span><br><span class="line">            tmp[arr[i]] = 1;</span><br><span class="line">            newArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组下标判断法, 遍历数组，利用indexOf判断元素的值是否与当前索引相等，如相等则加入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    var newArr = [];</span><br><span class="line">    arr.forEach((e,i,arr) =&gt; &#123;</span><br><span class="line">        if(arr.indexOf(e) === i) &#123;</span><br><span class="line">            newArr.push(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6-Set</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...new Set([&apos;1&apos;,2,3,4,1,2,12,2])]</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组先排序， 然后比较俩数组一头一尾进行去重。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    var newArr = [], end;</span><br><span class="line">    arr.sort();</span><br><span class="line">    end = arr[0];</span><br><span class="line">    newArr.push(arr[0]);</span><br><span class="line">    for(let i = 1, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        if(arr[i] !== end) &#123;</span><br><span class="line">            newArr.push(arr[i]);</span><br><span class="line">            end = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用键值对-对象不能相同名来去重。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//有缺陷,当数组中存放1和‘1’会默认去掉其中一个，从而达不到想要的效果</span><br><span class="line">const unique = arr =&gt; &#123;</span><br><span class="line">    var obj = &#123;&#125;;</span><br><span class="line">    arr.forEach(value =&gt; &#123;</span><br><span class="line">        obj[value] = 0;</span><br><span class="line">    &#125;)</span><br><span class="line">    return Object.keys(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="作用域及作用域链"><a href="#作用域及作用域链" class="headerlink" title="作用域及作用域链"></a>作用域及作用域链</h4><p>js作用域分为：全局作用域、局部作用域<br>作用域定义：当函数执行时，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，它所产生的执行上下文就会被销毁。<br>简单来说在作用域内声明函数会创建函数作用域子节点，遇{}会创建块级作用域子节点，从而形成作用域链。</p>
<p>[[scope]]<br>每个JS函数都是一个对象，对象中有些属性我们可以访问，但有的不可以，这些属性仅供JS引擎存取。[[scope]]就是一个。它就是指作用域，其中存储了运行期上下文的集合，这个集合是链式连接，它就是作用域链。</p>
<p>变量值查找<br>在当前作用域往上查找，找到第一个匹配的标识符时就会停止返回。变量值，如果查找全局作用域都没有，则抛出reference error错误，因此变量值查找有就近原则。</p>
<p>es6中块级作用域在es5中的实现（闭包和变量改名）<br>由于是es6的东西，所以有很多浏览器以前的JS引擎不支持，所以出现了babel编译神器，需要将es6的代码编译成低版本的JS引擎的代码。</p>
<h4 id="let-和-var-和-const-的区别"><a href="#let-和-var-和-const-的区别" class="headerlink" title="let 和 var 和 const 的区别"></a>let 和 var 和 const 的区别</h4><p>var function声明的变量会依附最近的函数作用域或全局作用域。<br>es6中let、const声明的变量依附于最近的块级作用域、函数作用域或全局作用域。<br>而变量声明是因为JS引擎有一个预编译的过程。<br>js预编译会将变量提升。<br>预编译会暗示全局变量：变量若未声明就赋值，即归属全局对象。一切声明的全局变量全是window属性。</p>
<p>预编译步骤（4步骤）：</p>
<ol>
<li>创建 AO 对象。</li>
<li>寻找形参和变量声明，将变量和形参作为AO对象的属性名添加到对象中，值为undefined。值得注意的是，函数声明不叫变量。</li>
<li>将实参值和形参值相统一。</li>
<li>在函数体里面寻找函数声明，将函数名作为属性名，值为这个函数的函数体。</li>
</ol>
<p>function函数声明会首先被提升，才是变量。<br>let和const是es6新特性，不会被提升。<br>function，var在同一作用域重复声明变量，后者会覆盖前者，let和const会直接抛出语法错误。<br>const声明变量的同时需要赋值，否则会抛出语法错误，且变量的指向不会变，而引用类型的内容可以变。故常用于声明常量和对象。</p>
<h4 id="闭包的理解和应用"><a href="#闭包的理解和应用" class="headerlink" title="闭包的理解和应用"></a>闭包的理解和应用</h4><p>闭包<br>在一个函数内部在定义一个函数，并且这个内部函数与外部函数的变量有关联，通过返回这个内部函数来访问外部函数里面的变量。<br>当内部函数被保存到外部时，将会生成闭包。<br>闭包会导致原有作用域链不释放，造成内存泄漏。</p>
<p>闭包的作用<br>实现公有变量（函数累加器）<br>可以做缓存（存储结构）<br>可以实现封装，属性私有化<br>模块化开发，防止污染全局变量</p>
<p>闭包的防范<br>闭包会导致多个执行函数共用一个公有变量，如果不是特殊需要，应尽量防止这种情况发生。</p>
<p>立即执行函数（没有声明，一次执行后释放，适合做初始化工作）:<br>解闭包的一个重要方法，通过另一个新闭包来消除上一个闭包的影响(function () {} ())           (function () {})()</p>
<h4 id="构造函数及new"><a href="#构造函数及new" class="headerlink" title="构造函数及new"></a>构造函数及new</h4><p>构造函数<br>一种特殊的方法主要用来在创建对象时初始化对象，即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</p>
<ol>
<li>在函数体最前面隐式的加上this</li>
<li>执行this.xxx = xxx</li>
<li>隐式的返回this</li>
</ol>
<p>new是什么？<br>new其实是JS语法中的一个语法糖。当我们要创建一个对象的实例时。我们要去继承这个对象的原型。那么new的作用就是帮你自动完成4个步骤。</p>
<ol>
<li>帮你创建一个新对象。 var obj = new Object();</li>
<li>帮你绑定原型。obj.<strong>proto</strong> = Object.prototype 将新对象的<strong>proto</strong>属性指向构造函数的prototype</li>
<li>帮你将this指向新对象。</li>
<li>帮你return新对象。但在这里注意构造函数是否有返回值。如果构造函数的返回值为基本数据类型（number，string，boolean，undefined，null）则返回临新对象。如果构造函数的返回值为对象类型，则返回这个对象类型。</li>
</ol>
<h4 id="call-apply-bind-this"><a href="#call-apply-bind-this" class="headerlink" title="call/apply/bind/this"></a>call/apply/bind/this</h4><p>其中call/apply作用都是改变this指向，区别只是后面传的参数形式不同。<br>call(thisArg,[arg1,[arg2,[…]]])，apply(thisArg,[arrs])<br>bind也能改变this指向。但是bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入bind()方法的第一个参数作为this，传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
<p>this是一个指向。<br>在函数预编译过程中this指向window对象。在全局作用域里this也指向window对象。<br>最后 <strong>this永远指向最后调用它的那个对象</strong>。<br>那么我们如何改变this指向？</p>
<ol>
<li>在函数内部使用 var that = this</li>
<li>使用apply、call、bind函数改变this指向</li>
<li>用new实例化一个对象</li>
<li>使用es6的箭头函数</li>
</ol>
<h4 id="proto和prototype"><a href="#proto和prototype" class="headerlink" title="proto和prototype"></a><strong>proto</strong>和prototype</h4><p>JS中的<strong>proto</strong>总是指向prototype。<br>在es6之前，我们要改变一个原型，要这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var F = fucntion()&#123;&#125;;</span><br><span class="line">F.prototype = Father.prototype;</span><br><span class="line">var son = new F();</span><br></pre></td></tr></table></figure></p>
<p>这样我们就可以实现将<code>son.__proto__ = Father.prototype</code>。<br>而在es6中，我们就可以很方便了。<br>因为使用object.create()方法：可以在原型上生成新的对象的实例。<br>只需要这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Father()&#123;&#125;;</span><br><span class="line">var son = Object.creat(new Father);</span><br></pre></td></tr></table></figure></p>
<h4 id="js时间线"><a href="#js时间线" class="headerlink" title="js时间线"></a>js时间线</h4><ol>
<li>创建Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段document.readyState = ‘loading’。</li>
<li>遇到link外部css，创建线程加载，并继续解析文档。<br>(css异步加载，继续往下解析HTML结构，但不渲染，等JS加载完后在渲染）</li>
<li>遇到script外部js，并且没有设置async、defer，浏览器加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。</li>
<li>遇到script外部js，并且设置有async、defer，浏览器创建线程加载，并继续解析文档。对于async属性的脚本，脚本加载完成后立即执行。（异步禁止使用document.write()）</li>
<li>遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。</li>
<li>当文档解析完成，document.readyState = ‘interactive’。</li>
<li>文档解析完成后，所有设置有defer的脚本会按照顺序执行。（注意与async的不同,但同样禁止使用document.write()）;</li>
<li>document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。</li>
<li>当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = ‘complete’，window对象触发load事件。</li>
<li>从此，以异步响应方式处理用户输入、网络事件等。</li>
</ol>
<h4 id="深拷贝、浅拷贝"><a href="#深拷贝、浅拷贝" class="headerlink" title="深拷贝、浅拷贝"></a>深拷贝、浅拷贝</h4><p>浅拷贝：原始类型为值传递，对象类型仍为引用传递。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function clone(src, tar) &#123; // src 源对象，tar 目标对象    </span><br><span class="line">    var tar = tar || &#123;&#125;;    </span><br><span class="line">    for(var prop in src) &#123;        </span><br><span class="line">        tar[prop] = src[prop];    </span><br><span class="line">    &#125;    </span><br><span class="line">    return tar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>深拷贝：复制下所有属性，与原对象不在有联系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(src,tar)&#123;    </span><br><span class="line">    var tar= tar|| &#123;&#125;;    </span><br><span class="line">    for (var prop in src)&#123;        </span><br><span class="line">        if (typeof(src[prop]) == &apos;object&apos;)&#123; </span><br><span class="line">            tar[prop] = (src[prop].constructor === Array ) ? [] : &#123;&#125;;            </span><br><span class="line">            deepCopy(src[prop],tar[prop]); </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            tar[prop] = src[prop];        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    return tar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ES6中，Object.assign可以实现 <strong>对象</strong> 的浅拷贝<br>数组方法slice(0)可以实现对 <strong>数组</strong> 的浅拷贝<br>数组方法concat([])可以实现对 <strong>数组</strong> 的深拷贝</p>
<h4 id="隐式类型转化"><a href="#隐式类型转化" class="headerlink" title="隐式类型转化"></a>隐式类型转化</h4><ol>
<li><p>当字符串和数字之间相等比较的时候，都会先将字符串强制转换成数字再比较。<br><code>25 == &quot;25&quot;  //true</code></p>
</li>
<li><p>当其他类型和布尔类型相等比较的时候，都会先将布尔类型强制转换为数字再比较。<br><code>&quot;25&quot; == false //false</code><br><code>&quot;0&quot; == false  //true</code></p>
</li>
<li><p>如果是对象（对象、函数、数组）和非对象之间相等比较时，会进行ToPrimitive操作（转换为原始类型）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;abc&quot; == Object(&quot;abc&quot;);  //true</span><br><span class="line">null == Object(null);  //false</span><br><span class="line">undefined == Object(undefined);  //false</span><br><span class="line">NaN == Object(NaN);  //false</span><br></pre></td></tr></table></figure>
<p>Object(“abc”)执行ToPrimitive操作后，返回了”abc”原始值，所以结果为true。<br>Object(null)和Object(undefined)<br>执行完ToPrimitive操作后和Object()是一样的，所以结果为false。<br>最后一个结果为false，是因为NaN不等于NaN。</p>
</li>
<li><p>特殊情况。<br><code>null == undefined</code> </p>
</li>
</ol>
<h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>节点的类型<br>节点的类型 与 对应的 nodeType（可用 nodeType 查看节点的 类型）<br>元素节点————&gt;1 // 例：<code>&lt;div&gt;</code><br>属性节点————&gt;2 // 例：id,class<br>文本节点————&gt;3 // 例：123<br>注释节点————&gt;8 // 例：<code>&lt;!—— ——&gt;</code><br>document————&gt;9 // 例：#doucment<br>DocumentFragment————&gt;11</p>
<p>选择元素节点选择元素节点的方法（6种）：</p>
<ol>
<li>document.getElementById // 在ie8以下的浏览器中，不区分大小写，而且标签的name属性也可以被当做id被选择出来</li>
<li>document.getElementsByClassName // ie8及以下的版本中没有这种方法</li>
<li>document.getElementsByTagName // 兼容所有浏览器</li>
<li>document.getElementsByName // 只有部分标签的name可以生效，表单、表单元素、img、iframecss选择器:</li>
<li>querySelector() // ie7及以下的版本中没有这种方法</li>
<li>6.querySelectorAll() // ie7及以下的版本中没有这种方法</li>
</ol>
<p>遍历节点树 &amp; 遍历元素节点树</p>
<p>节点树的遍历：</p>
<ol>
<li>dom.parentNode 查找父节点</li>
<li>dom.childNodes 查找子节点们</li>
<li>dom.firstChild 第一个子节点</li>
<li>dom.lastChild 最后一个子节点</li>
<li>dom.nextSibling 下一个兄弟节点</li>
<li>dom.previousSibling 上一个兄弟节点</li>
</ol>
<p>元素节点树的遍历：</p>
<ol>
<li>dom.parentElement 返回当前元素的父元素节点</li>
<li>dom.children 所有子元素节点</li>
<li>dom.childElementCount 这个属性就是子元素节点的数量// dom.children.length === dom.childElementCount</li>
<li>dom.nextElementSibling 下一个兄弟元素节点</li>
<li>dom.previousElementSibling 上一个兄弟元素节点</li>
</ol>
<p>增 ／ 插 ／ 替换 ／ 删除 操作</p>
<p>新增 dom 元素：</p>
<ol>
<li>创建元素节点 document.createElement()</li>
<li>创建文本节点 document.createTextNode()</li>
<li>创建注释节点 document.createComment()</li>
<li>创建文档碎片 document.createDocumentFragment()</li>
</ol>
<p>插入 dom 元素：</p>
<ol>
<li>dom1.appendChild(dom2); // 在dom1中最后的位置插入dom2</li>
<li>dom1.insertBefore(dom2, dom3); // 在dom1下，把dom2插入到dom3前</li>
</ol>
<h4 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h4><p>定义：Browser Object Model，定义了操作浏览器的接口<br>BOM对象: Window, History,Navigator,Screen, Location等</p>
<p>window 对象:表示浏览器中打开的窗口。<br>window 对象上有特别多的方法，一般来讲，能全局使用的都是 window 对象上的方法，例如我们常用的一些：<br>console，setInterval，setTimeout，navigator，screen，history，location</p>
<p>navigator对象：<br>navigator.userAgent 目前用户使用的是 pc端 还是 移动端，是什么 浏览器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">问题：若是 移动端 跳转 移动端 url，若是 pc端 跳转 pc端 url？</span><br><span class="line">答案：</span><br><span class="line">if(/iphone|nokia|sony|ericsson|mot|samsung|sgh|lg|philips|panasonic|alcatel|lenovo|cldc|midp|wap|android|iPod/i.test(navigator.userAgent.toLowerCase()))&#123;</span><br><span class="line">    window.location.href=&quot;移动端url&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    window.location.href=&quot;pc端url&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>screen对象：</p>
<ol>
<li>screen.availHeight/screen.availWidth 可以查看除了window任务栏之外的屏幕的高度和宽度。</li>
<li>screen.height/screen.width 返回显示器的屏幕的高度和宽度,兼容的较少。</li>
<li>screen.deviceXDPI/screen.deviceYDPI 返回显示屏幕的分辨率。</li>
</ol>
<p>history对象：</p>
<ol>
<li>history.length 浏览历史的长度。</li>
<li>history.back() 进入到下一个历史页面。</li>
<li>history.forward() 返回到上一个历史页面。</li>
<li>history.go() 当参数是正数的时候，前进到下一个历史页面，当是负数的时候，回退到上一个历史页面。</li>
</ol>
<p>location对象：</p>
<ol>
<li>location.href 设置或返回当前的url</li>
<li>location.host 返回当前的主机名和当前的URL端口号</li>
<li>location.search 设置或返回从问号开始的URL(查询部分)</li>
<li>location.hash 跳转到相应的id的元素的位置(“#”后是对浏览器操作的,对服务器无效,实际发出的请求也不包含”#”后面的部分。 “#”被算作历史记录)</li>
<li>location.reload 重新加载当前页面</li>
</ol>
<h4 id="class特性与继承"><a href="#class特性与继承" class="headerlink" title="class特性与继承"></a>class特性与继承</h4><p>继承（6种方法）：</p>
<ol>
<li>原型链继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Father () &#123;&#125;</span><br><span class="line">function Son () &#123;&#125;</span><br><span class="line">Son.prototype = new Father()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>缺点：会继承过多没有用的属性，造成大量的浪费。</p>
<ol>
<li>构造函数继承 call / apply<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Father () &#123;&#125;</span><br><span class="line">function Son () &#123;Father.call(this)&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>缺点：这种方式不属于继承，也访问不了原型的原型。每次构造一个对象都要走一个构造函数，效率很低。</p>
<ol>
<li>共享原型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Father () &#123;&#125;</span><br><span class="line">function Son () &#123;&#125;</span><br><span class="line">Son.prototype = Father.prototype;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>缺点：没办法改变子类的原型，一改就两个一起改了。</p>
<ol>
<li>object.create() <strong>在原型上生成新的对象的实例</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Father () &#123;&#125;var son = Object.create(new Father);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>缺点：object.creat方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象上。所以这个继承得到的不是类，只是得到对象。好处：这个方法在你想要改变一个的原型来创建实例而言会特别好用。</p>
<ol>
<li>圣杯模式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var inherit = (function ()&#123;</span><br><span class="line">    var F = function()&#123;&#125;; </span><br><span class="line">    return function (C,P)&#123;</span><br><span class="line">        F.prototype = P.prototype;        </span><br><span class="line">        C.prototype = new F();        </span><br><span class="line">        C.prototype.constructor = C;        </span><br><span class="line">        C.prototype.uber = P;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>F 函数的作用：沟通 P 和 C 的原型，这样我们改变 C 的原型的时候只会影响 F 而不会影响 P。</p>
<ol>
<li>extends（es6 方法）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;&#125;</span><br><span class="line">class Son extends Father &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>在JS中，所有的代码都是单线程执行的，所以JS的所有网络操作，浏览器事件都必须异步执行。而异步需要大量回调函数会导致页面结构混乱，形成可怕的回调地狱。<br>而ES6的Promise就是一个语法糖，帮助我们规范化书写回调函数。（采用链式调用的方法异步执行JS）<br>Promise对象有三个状体：<br>Pending（起始状体，进行中）<br>Resolved（成功）<br>Rejected（失败）<br>Pending –&gt; Resolved 或 Pending –&gt; Rejected<br>状体改变后不会在变</p>
<p>Promise 对象<br>var promise = new Promise(function(resolved,rejected){});</p>
<p>Promise.catch<br>如果promise.then不传第二个参数，可以用promise.catch方法来获取promise对象失败时传来的数据，是rejected的语法糖</p>
<h4 id="jQuery的链式调用-无new构造"><a href="#jQuery的链式调用-无new构造" class="headerlink" title="jQuery的链式调用/无new构造"></a>jQuery的链式调用/无new构造</h4><p>jQuery.fn.init.prototype = jQuery.fn </p>
<ol>
<li>首先要明确，使用 $(‘xxx’) 这种实例化方式，其内部调用的是 return new jQuery.fn.init(selector, context, rootjQuery) 这一句话，也就是构造实例是交给了 jQuery.fn.init() 方法去完成。</li>
<li>将 jQuery.fn.init 的 prototype 属性设置为 jQuery.fn，那么使用 new jQuery.fn.init() 生成的对象的原型对象就是 jQuery.fn ，所以挂载到 jQuery.fn 上面的函数就相当于挂载到 jQuery.fn.init() 生成的 jQuery 对象上，所有使用 new jQuery.fn.init() 生成的对象也能够访问到 jQuery.fn 上的所有原型方法。</li>
<li>也就是实例化方法存在这么一个关系链  </li>
</ol>
<p>jQuery.fn.init.prototype = jQuery.fn = jQuery.prototype ;<br>new jQuery.fn.init() 相当于 new jQuery() ;<br>jQuery() 返回的是 new jQuery.fn.init()，而 var obj = new jQuery()，所以这 2 者是相当的，所以我们可以无 new 实例化 jQuery 对象。</p>
<h4 id="正则-待补充"><a href="#正则-待补充" class="headerlink" title="正则(待补充)"></a>正则(待补充)</h4><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="get-post-待补充"><a href="#get-post-待补充" class="headerlink" title="get/post(待补充)"></a>get/post(待补充)</h4><p>正常标准回答：</p>
<pre><code>* GET在浏览器回退时是无害的，而POST会再次提交请求。
* GET产生的URL地址可以被Bookmark，而POST不可以。
* GET请求会被浏览器主动cache，而POST不会，除非手动设置。
* GET请求只能进行url编码，而POST支持多种编码方式。
* GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
* GET请求在URL中传送的参数是有长度限制的，而POST么有。
* 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
* GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
* GET参数通过URL传递，POST放在Request body中。
</code></pre><p>本质上：<br>    GET/POST是HTTP协议中的两种发生请求的方法。HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。<br>    故GET/POST底层也是TCP/IP，TCP用来传输数据，IP用来给数据加上唯一身份标识。HTTP则是定义传输网络中的交通规则。HTTP设定了GET/POST/PUT/DELETE。且规定执行GET请求时，给数据设置method为GET，把数据防止url后方便记录。POST则给数据设置method为POST，把数据放在请求体里。当然HTTP只是行为准则，你也可以在post请求的时候把数据放在url后面，而TCP才是GET和POST实现的基本。<br>    接收http请求的服务器为了节省它们的负担，会限制单次运输量。大多数浏览器会限制url长度在2k个字节，而大多数服务器最多处理64k字节url，超出部分不做处理。<br>    GET请求产生一个TCP包。浏览器会把http header和data一起发送，服务器响应200返回数据。<br>    POST产生两个TCP包。浏览器先发送header，服务器响应100 continue，浏览器再发送data服务器响应200 ok返回数据。<br>    其中GET和POST有自己的语义，不能随便混用，且网络好的时候发一次包与两次包间的时间差可以无视，在网络差时，两次包的TCO在验证数据包完整性上有非常大的优点。并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p>
<h4 id="cookie-localstorage-Session-待补充"><a href="#cookie-localstorage-Session-待补充" class="headerlink" title="cookie localstorage Session(待补充)"></a>cookie localstorage Session(待补充)</h4><p>客户端存储:<br>localStorage: 存储量在5M以上，浏览器关闭不会失效<br>sessionStorage: 存储量在5M以上，浏览器关闭失效<br>cookie: 存储量不大于4k，过期失效</p>
<p>localStorage/sessionStorage 操作方法:<br>1.setItem(name,val) 设置属性值<br>2.getItem(name) 获得属性值<br>3.removeItem(name) 移出属性值<br>4.clear() 清除所有属性</p>
<p>cookie 操作方法:<br>1.存储 cookie：document.cookie = “name=duanran;expires=10000;” // 时间为10000毫秒<br>2.查看 cookie：document.cookie<br>3.删除 cookie：document.cookie = “name=;expires=-1;” // 时间设置为-1</p>
<h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p>三次握手，四次挥手三次握手：</p>
<pre><code>* 客户端–发送带有SYN标志的数据包–一次握手–服务端
* 服务端–发送带有SYN/ACK标志的数据包–二次握手–客户端
* 客户端–发送带有带有ACK标志的数据包–三次握手–服务端
</code></pre><p>四次挥手：</p>
<pre><code>* 客户端-发送一个FIN，用来关闭客户端到服务器的数据传送
* 服务器-收到这个FIN，它发回一个ACK，确认序号为收到的序号加1 。和SYN一样，一个FIN将占用一个序号
* 服务器-关闭与客户端的连接，发送一个FIN给客户端
* 客户端-发回ACK报文确认，并将确认序号设置为收到序号加1
</code></pre><h4 id="AJAX-Fetch"><a href="#AJAX-Fetch" class="headerlink" title="AJAX/Fetch"></a>AJAX/Fetch</h4><p>AJAX<br>AJAX是一种用于创建快速动态网页的技术，通过在后台与服务器进行少量数据交换，AJAX可以使网页实现异步更新。意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
<p>AJAX 优缺点<br>AJAX 优点:</p>
<pre><code>1. 页面无刷新，用户体验好
2. 使用异步的形式与服务器进行通信，响应更快
3. 减少冗余请求，减轻服务器的负担
4. 基于标准化的并被广泛支持的技术，不需要插件或者小程序
</code></pre><p>AJAX缺点:</p>
<pre><code>1. 不支持浏览器的后退机制
2. 对搜索引擎支持较弱
3. 无法使用URL直接访问
4. 破坏了程序异常机制
5. 存在一定安全问题
</code></pre><p>AJAX包含技术</p>
<pre><code>1. 使用CSS和XHTML表示
2. 使用javascript来绑定和调用
3. 使用DOM模型来交互和动态显示
4. 使用XMLHttpRequest来和服务器进行异步通信
</code></pre><p>XMLHttpRequest目前虽然还没有被W3C所采纳，但它已经是一个事实的标准，因为目前几乎所有的主流浏览器都支持它。</p>
<p>AJAX 步骤<br>通过XMLHttpRequest对象来向服务器发起异步请求，从服务器获取数据，用JavaScript来操作DOM更新页面。</p>
<ol>
<li>创建 ajax 对象<br>var xml = XMLHttpRequest() //主流浏览器<br>var xml = ActiveXObject(‘Mircosoft.XMLHTTP’) //IE5、IE6</li>
<li>创建与服务器的连接和调用<br>xml.open(get/post, url, anync) // 第三个参数是boolean值，默认为true，异步模式</li>
<li>监听对象状态改变<br>xml.onReadyStateChange //监听对象状态改变<br>xml.readyState == 4 //响应已完成 返回0：请求未初始化; 返回1：请求已建立，但还没发送(send还没调用); 返回2：请求已发送，正在处理(通常现在可以获取到响应头); 返回3.请求正在处理中(通常现在可以获取到响应的部分数据，但服务器还没有完成响应的生成)<br>xml.status == 200 //“OK：请求已经被服务器正常处理”<br>callBack(responseText) // 若成功，通过回调函数接收 AJAX 返回的数据</li>
<li>向服务器发送数据xml.send()</li>
</ol>
<p>为什么监听要放到发送数据前边？因为因为现在网速是越来越快了，若网速非常快，刚刚请求数据，数据就已经返回回来了，但是代码还没有走到监听部分，这就导致了监听部分的失效。</p>
<p>使用GET请求：<br>将要提交的参数写到open方法里的url里，send传参为null或空。<br>xml.open(“GET”, url + ‘?’ + data, flag);<br>xml.send(null) 或 xml.send()<br>使用POST请求：<br>若要像HTML表单那样POST数据，使用setRequestHeader()来添加HTTP头，然后在send()方法里规定希望发送的数据格式<br>xml.open(“POST”, url, flag);<br>xml.setRequestHeader(‘Content-type’, ‘application/x-www-form-urlencoded’);<br>xml.send(data);</p>
<p>封装 AJAX<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function Ajax(method, url, flag, data, callback)&#123;</span><br><span class="line">    var xml = null;</span><br><span class="line">    //兼容性</span><br><span class="line">    if(window.XMLHttpRequest) &#123;</span><br><span class="line">        xml = new XMLHttpRequest();</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        xml = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    //将method值变为大写</span><br><span class="line">    method = method.toUpperCase();</span><br><span class="line">    //判断请求方式</span><br><span class="line">    if(method === &apos;GET&apos;)&#123;</span><br><span class="line">        xml.open(method, url + &apos;?&apos; + data, flag);</span><br><span class="line">        xml.send();</span><br><span class="line">    &#125;else if(method === &apos;POST&apos;)&#123;</span><br><span class="line">        xml.open(method, url, flag);</span><br><span class="line">        xml.setRequestHeader(&apos;Content-type&apos;, &apos;application/x-www-form-urlencoded&apos;);</span><br><span class="line">        xml.send(data);</span><br><span class="line">    &#125;</span><br><span class="line">    //监听</span><br><span class="line">    xml.onreadystatechange = function () &#123;</span><br><span class="line">        if(xml.readyState === 4) &#123;</span><br><span class="line">            if(xml.status === 200) &#123;</span><br><span class="line">                callback(xml.responseText);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alert(&apos;error&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Fetch<br>Fetch API：Fetch 是 XMLHttpRequest 的最新替代技术。Fetch API 提供了一个 fetch() 方法，被定义在 BOM 的 window 对象中。Fetch 方法返回的是一个 Promise 对象，让你能够对 请求 的 返回结果 进行检索。</p>
<p>Fetch 的优点：</p>
<pre><code>1. 语法简洁，更加语义化
2. 基于标准 Promise 实现，可以链式调用，支持 async/await
</code></pre><p>Fetch返回的response<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    body: ReadableStream</span><br><span class="line">    bodyUsed: false</span><br><span class="line">    headers: Headers</span><br><span class="line">    ok : true</span><br><span class="line">    redirected : false</span><br><span class="line">    status : 200</span><br><span class="line">    statusText : &quot;OK&quot;</span><br><span class="line">    type : &quot;cors&quot;</span><br><span class="line">    url : &quot;http://some-website.com/some-url&quot;</span><br><span class="line">    __proto__ : Response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Fetch 的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//fetch获取数据</span><br><span class="line">fetch(url).then(function (res) &#123; // 需要同源策略</span><br><span class="line">    return res.json();</span><br><span class="line">&#125;).then(function (data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;).catch(function (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line">//fetch发送数据</span><br><span class="line">const data = &#123;data:&apos;content&apos;&#125;;</span><br><span class="line">fetch(url, &#123;</span><br><span class="line">    method: &apos;post&apos;,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        &apos;Content-Type&apos;:&apos;application/json&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    body:JSON.stringify(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>Fetch处理异常<br>zlFetchFetch不会关心ajax是否成功，它只关心从服务器发送请求和接收响应。所以我们应该在响应失败时去抛出异常。那么我们可以使用zlFetch库，它会来帮我们进行异常处理。</p>
<p>Fetch是很好的方法，能发送和接收数据。不需要在编写XHR请求或依赖于jQuery。尽管Fetch很好，但是其错误处理不是很直接。在处理之前，需要让错误信息进入到catch方法中。使用zlFetch库，就不需要担心错误处理了。</p>
<h4 id="跨域跨域的方法"><a href="#跨域跨域的方法" class="headerlink" title="跨域跨域的方法"></a>跨域跨域的方法</h4><pre><code>1. flash
2. 服务器代理中转 // 将资源放在服务器上
3. iframe + document.domain // 主域名相同，子域名不同，在子页面 与 主页面 分别加上 document.domain
4. iframe + location.hash // 用 location.hash 值传递数据，将数据放到 url 里
5. iframe + window.name // 修改子页面的 window.name 让主页面获取到这个值
6. postMessage // 使用 iframe.contentWindow.postMessage 发送数据，在子页面绑定 message 事件接收数据
7. jsonp // script 标签 src 属性 不受同源策略限制(常用)
8. cors // 跨域资源共享，需要 浏览器 与 服务器 同时支持(常用)
</code></pre><h4 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h4><p>jsonp：<br>web 页面上 script 标签的 src 属性引入 js 文件不受跨域的影响，把资源直接放到 script 标签的 src 里面，相当于把 数据 以 json 的形式放到服务器上。无法监控 script 的 src 的加载状态，不知道数据有没有获取完成，所以我们要事先定义好处理函数，这个处理函数就是 jsonp。<br>jsonp 的工作原理：script 标签的 src 向服务器发送了一个 GET 请求，同时 将约定好 的参数写到 url 上面。同源策略 只限制客户端，服务器端没有这个限制，因此服务器端 接收到 这个请求之后会 响应它。根据 url 上面的 参数 自动生成一串 json 数据 并且 格式化，然后返回到 发送请求 的页面上。script 标签获取到这个 字符串 之后 自动转化成 js 对象，然后执行这一段代码。</p>
<p>jsonp 优点：</p>
<pre><code>1. JSONP 可以跨越同源策略
2. 兼容性好
3. 可以定义 callback 处理函数，处理函数交给了调用方
</code></pre><p>jsonp 缺点：</p>
<pre><code>1. 只支持 GET 请求而不支持 POST 请求
2. 调用失败的时候不会返回各种 HTTP 状态码
3. 安全性不高
</code></pre><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>cors 与 jsonp 相比的优点：<br>JSONP 只支持 GET 请求，CORS 支持所有类型的 HTTP 请求（get／post／put／delete）</p>
<p>使用 cors：<br>在请求头中，添加 Origin 字段。<br>Origin 字段用来说明，请求来自哪个源（协议 + 域名 + 端口）。<br>服务器根据这个值，决定是否同意这次请求。<br><code>Origin: https://wildbanana001.github.io/</code><br>在响应头中，服务器会返回 Access-Control-Allow-Origin 字段。<br>Access-Control-Allow-Origin 字段的值,要么是 Origin 的值，要么是 *（接受 任意 域名 的请求），表示接受这个域名的请求。<br>要是没有返回 Access-Control-Allow-Origin 字段，则代表出错了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: https://wildbanana001.github.io/</span><br><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure></p>
<h4 id="网络请求过程（在浏览器输入url）"><a href="#网络请求过程（在浏览器输入url）" class="headerlink" title="网络请求过程（在浏览器输入url）"></a>网络请求过程（在浏览器输入url）</h4><pre><code>* 输入地址
* 浏览器查找域名的 IP 地址 这一步包括 DNS 具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存...
* 浏览器向 web 服务器发送一个 HTTP 请求  
* 服务器的永久重定向响应（从http://www.example.com到http://www.example）
* 浏览器跟踪重定向地址
* 服务器处理请求
* 服务器返回一个 HTTP 响应
* 浏览器显示 HTML    (以下部分具体可看JS时间线)
* 浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）
* . 浏览器发送异步请求
</code></pre><h4 id="应用层协议-待补充"><a href="#应用层协议-待补充" class="headerlink" title="应用层协议(待补充)"></a>应用层协议(待补充)</h4><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。所以Http连接是一种短连接，是一种无状态的连接。<br>所谓的无状态，是指浏览器每次向服务器发起请求的时候，不是通过一个连接，而是每次都建立一个新的连接。如果是一个连接的话，服务器进程中就能保持住这个连接并且在内存中记住一些信息状态。而每次请求结束后，连接就关闭，相关的内容就释放了，所以记不住任何状态，成为无状态连接。</p>
<h4 id="HTTP1-1-与-HTTP2-0区别"><a href="#HTTP1-1-与-HTTP2-0区别" class="headerlink" title="HTTP1.1 与 HTTP2.0区别"></a>HTTP1.1 与 HTTP2.0区别</h4><ol>
<li>在浏览器端，HTTP/2仅能在TLS下运行，也就是HTTPS。这不是因为HTTP/2标准强制要求，而是全球两大浏览器领导者 —— Firefox和Chrome都明确地表示，他们只会实现基于TLS的HTTP/2。</li>
<li>HTTP/2取消了大量头字段，并且取消了小版本号。也就是说服务器和客户端都必须确定自己是否完整兼容http2或者彻底不兼容。</li>
<li>HTTP/2不再是一个基于文本的协议，通过新增的二进制分帧层变成了一个二进制协议，这意味着：<br>HTTP/2使用二进制帧进行数据交换。HTTP/2规范中一共定义了10种帧，其中最基础的两种分别对应于HTTP/1.1的DATA和HEADERS帧HTTP/2可以对压缩头信息进行压缩了。反正是二进制帧。</li>
<li>利用帧，HTTP/2可以在单个TCP连接上高效传输所有资源：通过在单个连接上建立多个流，实现流的多路复用。流可以指派一个优先级，也可以为流建立依赖关系。这样可以避免“浏览器明明在等关键的CSS和JS，服务器却还在发图片”。完全避免线头阻塞。</li>
<li>服务器可以利用RST_STREAM帧随时中断某个chunk的发送。</li>
<li>服务器可以主动向客户端推送资源让客户端缓存。当然，客户端可以使用RST_STREAM帧拒绝掉服务器的“好意”。</li>
<li>HTTP/2的流可以进行流量控制，通过公示流量窗口来限制另一端发送数据。</li>
</ol>
<h4 id="HTTP的基本优化"><a href="#HTTP的基本优化" class="headerlink" title="HTTP的基本优化"></a>HTTP的基本优化</h4><p>影响一个 HTTP 网络请求的因素主要有两个：带宽和延迟。</p>
<pre><code>* 带宽：如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。
* 延迟：

    * 浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。
    * DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。
    * 建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。
</code></pre><h4 id="HTTP1-0和HTTP1-1的一些区别"><a href="#HTTP1-0和HTTP1-1的一些区别" class="headerlink" title="HTTP1.0和HTTP1.1的一些区别"></a>HTTP1.0和HTTP1.1的一些区别</h4><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p>
<ol>
<li>缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li>带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li>错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li>Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li>
<li>长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li>
</ol>
<h4 id="HTTPS与HTTP的一些区别"><a href="#HTTPS与HTTP的一些区别" class="headerlink" title="HTTPS与HTTP的一些区别"></a>HTTPS与HTTP的一些区别</h4><p>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。<br>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。<br>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</p>
<h4 id="TCP和UDP的区别通用的-TCP-和-UDP-协议"><a href="#TCP和UDP的区别通用的-TCP-和-UDP-协议" class="headerlink" title="TCP和UDP的区别通用的 TCP 和 UDP 协议"></a>TCP和UDP的区别通用的 TCP 和 UDP 协议</h4><p>TCP 协议面向有连接，能正确处理丢包，传输顺序错乱的问题，但是为了建立与断开连接，需要至少7次的发包收包，资源浪费<br>UDP 面向无连接，不管对方有没有收到，如果要得到通知，需要通过应用层</p>
<h4 id="HTTP常见状体码"><a href="#HTTP常见状体码" class="headerlink" title="HTTP常见状体码"></a>HTTP常见状体码</h4><p>2XX 成功</p>
<pre><code>* 200 OK，表示从客户端发来的请求在服务器端被正确处理
* 204 No content，表示请求成功，但响应报文不含实体的主体部分
* 206 Partial Content，进行范围请求
</code></pre><p>3XX 重定向</p>
<pre><code>* 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
* 302 found，临时性重定向，表示资源临时被分配了新的 URL
* 303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源
* 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
* 307 temporary redirect，临时重定向，和302含义相同
</code></pre><p>4XX 客户端错误</p>
<pre><code>* 400 bad request，请求报文存在语法错误
* 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
* 403 forbidden，表示对请求资源的访问被服务器拒绝
* 404 not found，表示在服务器上没有找到请求的资源
</code></pre><p>5XX 服务器错误</p>
<pre><code>* 500 internal sever error，表示服务器端在执行请求时发生了错误
* 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求
</code></pre><h4 id="HTTP缓存-待补充"><a href="#HTTP缓存-待补充" class="headerlink" title="HTTP缓存(待补充)"></a>HTTP缓存(待补充)</h4><p>强制缓存cache-control、协商缓存if-modified，if-modified-since，e-tag了解一下</p>
<ol>
<li>当浏览器第一次向服务器请求资源时会去询问服务器这个资源该不该缓存，用什么方法缓存。假设服务器同意浏览器缓存，并告诉浏览器一个资源失效时间，这个时间存放在Expires中如：Mon,10 Dec 1990 02:25:22GMT。那么这个资源在这个时间之前都能使用。那么有一个问题是：客户端的时间是可以被修改的，而且客户端和服务器时间未必一致。</li>
<li>既然返回一个绝对时间不好用，那么服务器就返回一个相对时间好了，这个时间在Cache-Control:max-age=300单位是秒（s）。现在好了300秒内这个资源就不会过期。那么有一种可能是300秒后我再次去服务器拿这个资源发现资源并没有被改变过，服务器又再次返回了同样的资源给我，这样的话就浪费了一次带宽。其实可以返回一条信息给浏览器表明缓存资源可以继续使用。</li>
<li>现在回到浏览器第一次请求的时候，服务器响应头中多了一个ETag:W/“e-cbxLFQW5zapn79tQwb/g6Q”。这个ETag是服务器根据资源计算出的唯一标识，通常配合max-age使用。当时间过期以后浏览器会将标识放在请求头中的If-None-Match，服务器收到请求以后会拿请求中的标识与服务器根据资源计算的Etag进行比较，若一致则返回响应头其中包含状态码304。不一致就返回新的资源。但是在分布式系统中每个机器生成的ETag不一样。</li>
<li>既然ETag也不是那么的靠谱，那么服务器第一次返回时在响应头中又加了一个字段Last-Modified。当资源过期时浏览器发现资源有Last-Modified，然后发请求时便在请求头增加了一个字段If-Modified-Since表示发送的请求时间，服务器拿到这个时间与资源的最后修改时间比较，如果修改时间比较新那么返回新的资源，否则返回Http 304。</li>
</ol>
<p>当Expires与Cache-Control:max-age同时存在时max-age的优先级高。<br>[Last-Modified，If-Modified-Since]和[ETag、If-None-Match]经常会放在一起使用。</p>
<h4 id="HTTP缓存头部简述-待补充"><a href="#HTTP缓存头部简述-待补充" class="headerlink" title="HTTP缓存头部简述(待补充)"></a>HTTP缓存头部简述(待补充)</h4><h4 id="http的-nginx-服务器可以直接升级到https吗？-待补充"><a href="#http的-nginx-服务器可以直接升级到https吗？-待补充" class="headerlink" title="http的(nginx)服务器可以直接升级到https吗？(待补充)"></a>http的(nginx)服务器可以直接升级到https吗？(待补充)</h4><h4 id="http1-0短连接可以实现长连接吗？-待补充"><a href="#http1-0短连接可以实现长连接吗？-待补充" class="headerlink" title="http1.0短连接可以实现长连接吗？(待补充)"></a>http1.0短连接可以实现长连接吗？(待补充)</h4><h4 id="网络安全XSS攻击"><a href="#网络安全XSS攻击" class="headerlink" title="网络安全XSS攻击"></a>网络安全XSS攻击</h4><p>利用web应用中的计算机安全漏洞，注入外部JavaScript代码。</p>
<ol>
<li>非持久型xss攻击：仅对当次的页面访问产生影响。非持久型xss攻击要求用户访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户游览器执行，从而达到攻击目的。</li>
<li>持久型xss攻击：会把攻击者的数据存储在服务器端，攻击行为将伴随着攻击数据一直存在。</li>
</ol>
<p>或者也可分为三种</p>
<ol>
<li>反射型：经过后端，不经过数据库。 如利用input标签的html内插入script标签内容。</li>
<li>存储型：经过后端，经过数据库。 如利用input标签的html向数据库插入数据。</li>
<li>DOM：不经过后端，通过url传入参数去控制触发。 如利用img标签的src属性在里面插入可执行的代码。<br>防御：过滤非法字符（利用正则匹配），限制长度（截断），保护cookie可以使用cookie的HttpOnly属性，加上这个属性JS无法读写。 </li>
</ol>
<h4 id="网络安全CSRF攻击"><a href="#网络安全CSRF攻击" class="headerlink" title="网络安全CSRF攻击"></a>网络安全CSRF攻击</h4><p>跨站请求伪造。对网站中的一些提交行为进行恶意利用。</p>
<ol>
<li>合理使用post与get<br> get请求的参数会显示在url的后面，会被黑客提取，故保密的的信息应使用post请求。</li>
<li>加强post请求保护<br> 一、对post请求的数据加验证码，这样除了用户，黑客的网站获取不到本次session的验证码，但会降低用户提交体验。<br> 二、在用访问的页面中，都种下验证用的token，用户所有的提交都必须带上本次页面中生成的token，这种方式的本质和使用验证码没什么两样，但是这种方式，整个页面每一次的session，使用同一个token就行，很多post操作，开发者就可以自动带上当前页面的token。如果token校验不通过，则证明此次提交并非从本站发送来，则终止提交过程。如果token确实为本网站生成的话，则可以通过。</li>
<li>网络劫持攻击<br> 很多的时候，我们的网站不是直接就访问到我们的服务器上的，中间会经过很多层代理，如果在某一个环节，数据被中间代理层的劫持者所截获，他们就能获取到使用你网站的用户的密码等保密数据。这里推荐将网站从http升级为https。或者对提交的信息内容进行非对称性加密–在客户端加密，在服务端才能解开。</li>
<li></li>
</ol>
<h4 id="设计模式-待补充"><a href="#设计模式-待补充" class="headerlink" title="设计模式(待补充)"></a>设计模式(待补充)</h4><h5 id="观察者模式-订阅-发布模式-自定义事件"><a href="#观察者模式-订阅-发布模式-自定义事件" class="headerlink" title="观察者模式(订阅/发布模式)(自定义事件)"></a>观察者模式(订阅/发布模式)(自定义事件)</h5><p>目的：一个对象观察另一个对象的特定活动并在状态改变后获得通知。<br>实质：通过创建”可观察的”对象，当发生一个感兴趣的事件时可将该事件通告给所有观察者，形成松散耦合。<br>所有的浏览器事件(鼠标悬停，按键等事件)都是该模式例子。</p>
<h5 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h5><p>目的：单向数据绑定。</p>
<h5 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h5><p>目的：双向数据绑定。</p>
<h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><p>目的： 当创建相似对象时执行重复操作。 在编译时不知道具体类型(类)的情况下，为工厂客户提供一种创建对象的接口。</p>
<p>使用工厂模式不用new或对象字面量的构造函数，依据创建时传参来指定类型创建对象的接口。<br>例：<code>var corolla = CarMaker.factory(&#39;Compact&#39;);</code></p>
<h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>思想：保证一个特定类仅有一个实例。<br>实质：保证每次创建的实例对象this指向原来的实例。<br>使用JavaScript中的对象创建对象字面量时，它就是一个单例。因为每一个对象的空间地址不同，所以两个对象的空间地址不同，故两个对象不会相等。</p>
<p>JavaScript实现单例：</p>
<ol>
<li>使用new操作符实例构造函数。(new会得this指向该对象实例this)</li>
<li>在构造函数的静态属性中缓存该实例。(在实例中定义一个变量接收this)</li>
<li>将该实例包装在闭包中</li>
</ol>
<h5 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h5><p>目的：对对象实现互相通信，形成松耦合，提高可维护性。<br>实质：使用一个中介者(mediator)对象来保存其他对象的信息，通过它去通知其他对象状态改变。<br>在mediator对象中定义用户信息，状态，交互方法。当要改变数据都要经过调用mediator上的属性或方法。通过使对象之间并不直接”通话”，而是仅通过一个中介者对象进行通信，从而促进形成松散耦合。</p>
<h5 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h5><p>目的：可在运动时动态添加附加功能到对象中。<br>实质：通过从预定于装饰者对象中添加功能，从而在运行时调整对象。<br>实现装饰者模式的其中一个方法是使得每个装饰者成为一个对象，并且该对象包含了应该被重载的方法。每个装饰者实际上继承了目前已经被前一个装饰者进行增强后的对象。每个装饰方法在“继承的对象”上调用了同样的方法并获取其值，此外它还继续执行了一些操作。</p>
<h3 id="前端工程化-待补充"><a href="#前端工程化-待补充" class="headerlink" title="前端工程化(待补充)"></a>前端工程化(待补充)</h3><h3 id="前端性能优化-待补充"><a href="#前端性能优化-待补充" class="headerlink" title="前端性能优化(待补充)"></a>前端性能优化(待补充)</h3><p>可跳转☞：<br><a href="https://wildbanana001.github.io/2018/05/03/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">https://wildbanana001.github.io/2018/05/03/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</a></p>
<h3 id="VUE-待补充"><a href="#VUE-待补充" class="headerlink" title="VUE(待补充)"></a>VUE(待补充)</h3><h4 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h4><p>new Vue()<br>-&gt; Init(Event &amp; Lifecycle)<br>-&gt; beforeCreate -&gt; init(injections &amp; reactivity)<br>-&gt; created<br>-&gt; Has ‘el’ option? ( -N&gt; when vm.$mount(el) is called -&gt; )<br>-Y&gt;  Has ‘template’ options  ( -N&gt; Compile el’s outerHTML as template <em> ) (-Y&gt; Compile template into render funcrion </em> )<br>-&gt; beforeMount<br>-&gt; Create vm.$el and replace ‘el’ with it<br>-&gt; mounted<br>-&gt; Mounted (-&gt; when data changes -&gt; beforeUpdate -OR&gt; updated -&gt; Virtual Dom re-render and patch)<br>-&gt; when vm.$destroy() is called<br>-&gt; beforeDestroy<br>-&gt; Teardown watchers, child components and event listeners<br>-&gt; Destroyed<br>-&gt; destroyed</p>
<p>方法生命周期<br>beforeCreate<br>-&gt; created<br>-&gt; beforeMount<br>-&gt; mounted<br>-&gt; ( beforeUpdate -OR&gt; updated)<br>-&gt; beforeDestroy<br>-&gt; destroyed </p>
<p>创建Vue实例<br>-&gt; 初始化事件和生命周期，初始化_init是vue设置在prototype的私有属性，初始化时，_init里有一个属性是vm._uid，每次创建一个Vue实例时加1，以确保每一个Vue实例都是独一无二的。<br>-&gt;初始化注入和反应<br>-&gt; 是否有el属性，若无看是否使用$mount方法挂载，满足则进入下一个周期<br>-&gt; 是否有template模板属性<br>-&gt; 如果没有，则将挂载的el对象的外部HTML作为template模板，如果有则编译template模板进入render渲染函数<br>-&gt; 创建虚拟el替代Vue实例里的el<br>-&gt; （在更新前当数据发生变化 或者 更新 则触发虚拟DOM进行重新渲染re-render 和 产生补丁patch)<br>-&gt; 开始销毁虚拟Vue<br>-&gt; 卸载watchers, child, components 和 eventlisteners<br>-&gt; 销毁，结束</p>
<h4 id="Vue双向数据绑定"><a href="#Vue双向数据绑定" class="headerlink" title="Vue双向数据绑定"></a>Vue双向数据绑定</h4><p>每当 new 一个 Vue，主要做了两件事：<br>第一个是监听数据：observe(data)，<br>第二个是编译 HTML：nodeToFragement(id)。<br>在监听数据的过程中，会为 data 中的每一个属性生成一个主题对象 dep。<br>在编译 HTML 的过程中，会为每个与数据绑定相关的节点生成一个订阅者 watcher，watcher 会将自己添加到相应属性的 dep 中。<br>修改输入框内容 =&gt; 在事件回调函数中修改属性值 =&gt; 触发属性的 set 方法。<br>发出通知 dep.notify() =&gt; 触发订阅者的 update 方法 =&gt; 更新视图。</p>
<h4 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h4><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<h4 id="vueRoute的实现方式"><a href="#vueRoute的实现方式" class="headerlink" title="vueRoute的实现方式"></a>vueRoute的实现方式</h4><p><a href="https://juejin.im/post/5ac61da66fb9a028c71eae1b" target="_blank" rel="noopener">https://juejin.im/post/5ac61da66fb9a028c71eae1b</a></p>
<h4 id="vue组件的数据传递"><a href="#vue组件的数据传递" class="headerlink" title="vue组件的数据传递"></a>vue组件的数据传递</h4><h3 id="其它-待补充"><a href="#其它-待补充" class="headerlink" title="其它(待补充)"></a>其它(待补充)</h3><h4 id="二叉树遍历思路"><a href="#二叉树遍历思路" class="headerlink" title="二叉树遍历思路"></a>二叉树遍历思路</h4><h4 id="树的广度和深度的优先遍历"><a href="#树的广度和深度的优先遍历" class="headerlink" title="树的广度和深度的优先遍历"></a>树的广度和深度的优先遍历</h4><h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><h4 id="创建线程的步骤"><a href="#创建线程的步骤" class="headerlink" title="创建线程的步骤"></a>创建线程的步骤</h4><h4 id="实现栈"><a href="#实现栈" class="headerlink" title="实现栈"></a>实现栈</h4><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>二分查找法是典型的对数级的事件复杂度O(logn)<br>对数级的时间复杂度的算法，对于数据量越大，越具备优势。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//二分查找，前提是数组为有序数组</span><br><span class="line">function binarySearch(target, arr) &#123;</span><br><span class="line">    let start = 0;</span><br><span class="line">    let end = arr.length - 1;</span><br><span class="line">    while(start &lt;= end) &#123;</span><br><span class="line">        let mid = parseInt(start + (end - start) / 2)</span><br><span class="line">        if (target == arr[mid]) &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125; else if(target &gt; arr[mid]) &#123;</span><br><span class="line">            start = mid + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            end = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="顺序搜索算法"><a href="#顺序搜索算法" class="headerlink" title="顺序搜索算法"></a>顺序搜索算法</h4><p>时间复杂度O(n)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function search(arr, target) &#123;</span><br><span class="line">    let index = -1;</span><br><span class="line">    for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if(arr[i] === target) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>时间复杂度O(n²),应尽量避免的复杂度，速度缓慢。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for(var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        for(var j = 0; j &lt; len - 1; j++) &#123;</span><br><span class="line">            if(arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>时间复杂度为O(n㏒n)<br>快速排序是分治策略的经典实现，分治策略如下：</p>
<ol>
<li>分解步骤：将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小。</li>
<li>解决步骤：递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。</li>
<li>合并步骤：将子问题的解组合成原问题的解。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">function quick(arr,left,right) &#123;</span><br><span class="line">    let index;</span><br><span class="line">    if(arr.length &gt; 1) &#123;</span><br><span class="line">        index = partition(arr,left,right);</span><br><span class="line">        if(left &lt; index - 1) &#123;</span><br><span class="line">            quick(arr,left,index - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(index &lt; right) &#123;</span><br><span class="line">            quick(arr,index,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">function quickSort(arr) &#123;</span><br><span class="line">    return quick(arr, 0, arr.length - 1);</span><br><span class="line">&#125;</span><br><span class="line">//划分操作函数</span><br><span class="line">function partition(arr,left,right) &#123;</span><br><span class="line">    const pivot = arr[Math.floor((right + left) / 2)];</span><br><span class="line">    let i = left,</span><br><span class="line">        j = right;</span><br><span class="line">    while(i &lt;= j) &#123;</span><br><span class="line">        while(compare(arr[i], pivot) === -1) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        while(compare(arr[j], pivot) === 1) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i &lt;= j) &#123;</span><br><span class="line">            swap(arr,i,j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line">//原地交换函数，非用临时数组</span><br><span class="line">function swap(arr,a,b) &#123;</span><br><span class="line">    [arr[a],arr[b]] = [arr[b],arr[a]];</span><br><span class="line">&#125;</span><br><span class="line">function compare(a,b) &#123;</span><br><span class="line">    if(a === b) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return a &lt; b ? -1 : 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><h3 id="三面-待补充"><a href="#三面-待补充" class="headerlink" title="三面(待补充)"></a>三面(待补充)</h3><h4 id="平时怎么学习的"><a href="#平时怎么学习的" class="headerlink" title="平时怎么学习的"></a>平时怎么学习的</h4><h4 id="你觉得最有成就感的事情是什么"><a href="#你觉得最有成就感的事情是什么" class="headerlink" title="你觉得最有成就感的事情是什么"></a>你觉得最有成就感的事情是什么</h4><h4 id="有过团队经历么"><a href="#有过团队经历么" class="headerlink" title="有过团队经历么"></a>有过团队经历么</h4><h4 id="了解前端技术前沿团队么"><a href="#了解前端技术前沿团队么" class="headerlink" title="了解前端技术前沿团队么"></a>了解前端技术前沿团队么</h4><h4 id="5年后想成为什么样的人"><a href="#5年后想成为什么样的人" class="headerlink" title="5年后想成为什么样的人"></a>5年后想成为什么样的人</h4><h4 id="为什么学前端"><a href="#为什么学前端" class="headerlink" title="为什么学前端"></a>为什么学前端</h4>
            
        </div>
    
</div>


                
                    <!-- Paradox Post Info -->
                    
                

                <!-- Post Comments -->
                
                    
                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2018/05/03/前端性能优化/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            أحدث
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2018/04/15/网络/" id="post_nav-older" class="next-content">
            أقدم
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?V/53wGualMuiPM3xoetD5Q==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>













<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.2 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
