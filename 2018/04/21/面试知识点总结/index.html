<!DOCTYPE html>
<html style="display: none;" >
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.2 -->
    <script>
        window.materialVersion = "1.5.2"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1',
            '1.5.0'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">














    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!-- Title -->
    
    <title>
        
            面试知识点总结 | 
        
        BLOG
    </title>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">

    <meta name="format-detection" content="telephone=no"/>
    <meta name="description" itemprop="description" content="">
    <meta name="keywords" content="">
    <meta name="theme-color" content="#0097A7">

    <!-- Disable Fucking Bloody Baidu Tranformation -->
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.en.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(a){try{localStorage.removeItem(a)}catch(b){}};lsloader.setLS=function(a,c){try{localStorage.setItem(a,c)}catch(b){}};lsloader.getLS=function(a){var c="";try{c=localStorage.getItem(a)}catch(b){c=""}return c};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var b=[];for(var a=0;a<localStorage.length;a++){b.push(localStorage.key(a))}b.forEach(function(e){var f=lsloader.getLS(e);if(window.oldVersion){var d=window.oldVersion.reduce(function(g,h){return g||f.indexOf("/*"+h+"*/")!==-1},false);if(d){lsloader.removeLS(e)}}})}catch(c){}};lsloader.clean();lsloader.load=function(f,a,b,d){if(typeof b==="boolean"){d=b;b=undefined}d=d||false;b=b||function(){};var e;e=this.getLS(f);if(e&&e.indexOf(versionString)===-1){this.removeLS(f);this.requestResource(f,a,b,d);return}if(e){var c=e.split(versionString)[0];if(c!=a){console.log("reload:"+a);this.removeLS(f);this.requestResource(f,a,b,d);return}e=e.split(versionString)[1];if(d){this.jsRunSequence.push({name:f,code:e});this.runjs(a,f,e)}else{document.getElementById(f).appendChild(document.createTextNode(e));b()}}else{this.requestResource(f,a,b,d)}};lsloader.requestResource=function(b,e,a,c){var d=this;if(c){this.iojs(e,b,function(h,f,g){d.setLS(f,h+versionString+g);d.runjs(h,f,g)})}else{this.iocss(e,b,function(f){document.getElementById(b).appendChild(document.createTextNode(f));d.setLS(b,e+versionString+f)},a)}};lsloader.iojs=function(d,b,g){var a=this;a.jsRunSequence.push({name:b,code:""});try{var f=new XMLHttpRequest();f.open("get",d,true);f.onreadystatechange=function(){if(f.readyState==4){if((f.status>=200&&f.status<300)||f.status==304){if(f.response!=""){g(d,b,f.response);return}}a.jsfallback(d,b)}};f.send(null)}catch(c){a.jsfallback(d,b)}};lsloader.iocss=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.iofonts=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.runjs=function(f,c,e){if(!!c&&!!e){for(var b in this.jsRunSequence){if(this.jsRunSequence[b].name==c){this.jsRunSequence[b].code=e}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var a=document.createElement("script");a.appendChild(document.createTextNode(this.jsRunSequence[0].code));a.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(a);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else{if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var d=this;var a=document.createElement("script");a.src=this.jsRunSequence[0].path;a.type="text/javascript";this.jsRunSequence[0].status="loading";a.onload=function(){d.jsRunSequence.shift();if(d.jsRunSequence.length>0){d.runjs()}};document.body.appendChild(a)}}};lsloader.tagLoad=function(b,a){this.jsRunSequence.push({name:a,code:"",path:b,status:"failed"});this.runjs()};lsloader.jsfallback=function(c,b){if(!!this.jsnamemap[b]){return}else{this.jsnamemap[b]=b}for(var a in this.jsRunSequence){if(this.jsRunSequence[a].name==b){this.jsRunSequence[a].code="";this.jsRunSequence[a].status="failed";this.jsRunSequence[a].path=c}}this.runjs()};lsloader.cssfallback=function(e,c,b){if(!!this.cssnamemap[c]){return}else{this.cssnamemap[c]=1}var d=document.createElement("link");d.type="text/css";d.href=e;d.rel="stylesheet";d.onload=d.onerror=b;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(d,a)};lsloader.runInlineScript=function(c,b){var a=document.getElementById(b).innerText;this.jsRunSequence.push({name:c,code:a});this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?MKetZV3cUTfDxvMffaOezg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        

    

    
        
            <link rel="stylesheet" href="/css/fontawesome.min.css">
        
    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-image: url(/img/bg.png);
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icons -->


    <style id="material_icons"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_icons","/css/material-icons.css?pqhB/Rd/ab0H2+kZp0RDmw==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==", true)</script>
    

    <!-- WebAPP Icons -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="BLOG">
    <meta name="msapplication-starturl" content="http://yoursite.com/2018/04/21/面试知识点总结/">
    <meta name="msapplication-navbutton-color" content="#0097A7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="BLOG">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://yoursite.com/2018/04/21/面试知识点总结/">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="面试知识点总结 | BLOG">
    <meta property="og:image" content="/img/favicon.png">
    <meta property="og:description" content="">
    

    
        <meta property="article:published_time" content="Sat Apr 21 2018 23:23:59 GMT+0800">
        <meta property="article:modified_time" content="Sat Apr 21 2018 23:31:04 GMT+0800">
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:card" content="summary_large_image">

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://yoursite.com/2018/04/21/面试知识点总结/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://yoursite.com/2018/04/21/面试知识点总结/index.html",
    "headline": "面试知识点总结",
    "datePublished": "Sat Apr 21 2018 23:23:59 GMT+0800",
    "dateModified": "Sat Apr 21 2018 23:31:04 GMT+0800",
    "author": {
        "@type": "Person",
        "name": "林凯锋",
        "image": {
            "@type": "ImageObject",
            "url": "/img/myavatar.png"
        },
        "description": "github.com/wildBanana001"
    },
    "publisher": {
        "@type": "Organization",
        "name": "BLOG",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/favicon.png"
        }
    },
    "keywords": "",
    "description": "",
}
</script>


    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head -->
    

</head>


    
        <body id="scheme-Isolation" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                
                    <!-- Isolation Header -->
                    <header class="header">
    <div class="header-wrapper">
        <!-- Header Copyright -->
        <div class="header-copyright">
            <div class="header-site">
                ©&nbsp;
                <script type="text/javascript">
                    var fd = new Date();
                    document.write(fd.getFullYear());
                </script>
                &nbsp;BLOG
            </div>
            <!--
            I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright.
            It will not impact the appearance and can give developers a lot of support :)

            很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
            它不会影响美观并可以给开发者很大的支持。 :)
            -->
            <div>
                Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a>
                <br>
                Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a>
            </div>
        </div>

        <!-- Header Title -->
        <span class="header-title header-item">
            <a href="/" title="BLOG">
                BLOG
            </a>
        </span>

        <p class="header-slogan header-item">
        
            
                github.com/wildBanana001
            
        
        </p>

        <!-- Header Nav -->
        <nav class="header-nav header-item">
            <span class="header-nav-item">
                <a href="/" title="Home">
                    <span>Home</span>
                </a>
            </span>

            <!-- Pages  -->
            
            
        </nav>

        <!-- Header SNS -->
        <div class="header-item header-sns_list">
    <!-- Twitter -->
    
        <a href="https://twitter.com/twitter" target="_blank">
            <i class="fa fa-twitter fa-lg" aria-hidden="true"></i>
        </a>
    

    <!-- Facebook -->
    
        <a href="https://www.facebook.com/facebook" target="_blank">
            <i class="fa fa-facebook fa-lg" aria-hidden="true"></i>
        </a>
    

    <!-- Google + -->
    
        <a href="https://www.google.com/" target="_blank">
            <i class="fa fa-google-plus fa-lg" aria-hidden="true"></i>
        </a>
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    

    <!-- LinkedIn -->
    

    <!-- Telegram -->
    
</div>

    </div>
</header>

                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    

                    <!-- Post TOC -->

    



<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                


    <!-- Isolation Post Header -->
    <!-- Post thumbnail -->
    
        <!-- Post Header Info -->
        <div class="post-header_info without-thumbnail">
            <!-- Author Avatar & Name -->
            <img src="/img/myavatar.png" class="avatar-img" width="44px" height="44px" alt="林凯锋's avatar">
            <span class="name-span">林凯锋</span>
        </div>

        <!-- Null Thumbnail -->
        <div class="post_thumbnail-null">
    
        </div>



                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    

    
        <div class="post-content_wrapper">
            <p class="post-title">
                面试知识点总结
            </p>
            <h2 id="面试常见知识点总结"><a href="#面试常见知识点总结" class="headerlink" title="面试常见知识点总结"></a>面试常见知识点总结</h2><h3 id="HTML与CSS部分"><a href="#HTML与CSS部分" class="headerlink" title="HTML与CSS部分"></a>HTML与CSS部分</h3><h4 id="BFC（Block-Formatting-Context）"><a href="#BFC（Block-Formatting-Context）" class="headerlink" title="BFC（Block Formatting Context）"></a>BFC（Block Formatting Context）</h4><pre><code>块级格式化上下文。
overflow : hidden
position: absolute 、fixed
display: inline-block 、table-cell 、table-caption
这些属性创建时会自动创建BFC。
新方式：只为创建BFC无任何副作用。 display: flow-root
BFC适用： 解决浮动问题、两栏布局、margin塌陷/合并
Flex(弹性)和 Grid(网格)布局中的元素也会自动创建类似BFC的机制，只是它们被称为 Flex Formatting Context(FFC,弹性格式上下文) 和 Grid Formatting Context(GFC,网格格式上下文)。
</code></pre><h4 id="css两栏布局实现方法"><a href="#css两栏布局实现方法" class="headerlink" title="css两栏布局实现方法"></a>css两栏布局实现方法</h4><p>① float + margin    给左边的元素一个固定宽度，向左浮动，给右边一个向右浮动，宽度为100%，设置margin-left为120px（避免重合，且间距为20px）② float + BFC    给左边的元素一个固定宽度，向左浮动，给右边一个overflow:hidden触发BFC特性。③ absolute     给父级一个position：relative。给左边position：absolute；left：0；及一个宽度。给右边position：absolute；right：0；left：120px;则可以实现自适应。④ flex    给父级设置display：flex。给自适应子级一个flex：1即可。css垂直居中① absolute + margin方法一：position:absolute;width:100px;height:100px;padding:10px;top:50%;left:50%;margin-left: -60px; /<em>(width+padding)/2</em>/margin-top: -60px; /<em>(height+padding)/2</em>/方法二：position:absolute;margin:auto;top:0;left:0;bottom:0;right:0;适用于绝大数情况② absolute + transform3d (ie8以下不适合)position: absolute;top: 50%; left: 50%;transform: translate(-50%,-50%);③ flexdisplay: flex;justify-content: center;align-items: center;css怪异盒模型与普通盒模型区别，在怪异盒模型中图片应该从哪一部分展开？以前HTML和CSS没有一个统一的标准，所以到后来出现统一标准后，要对老网页兼容，则出现了怪异模式。我们经常能看到HTML文档第一行有 &lt;!DOCTYPE html&gt;声明。说明这个页面遵守了HTML5规范的,浏览器会自动选择标准模式。怪异盒模型：box-sizing: border-box // IE6混杂模式的盒模型 border + padding + content = 设置的宽／高（width: …px / height: …px）所以 border-box 的总 宽／高 = content + margin图片对其方式：标准盒模型：verticle-align: baseline; (inline, tablecell)怪异盒模型：verticle-align: bottom; flex布局flex: 弹性容器(父元素) 、 弹性项目(子元素)实则flex布局后，子元素的float、clear和vertical-align属性会失效。弹性容器：flex-direction 定义排列的方向row 默认值，主轴为水平，从左向右排列row-reverse 主轴为水平，从右向左排列column 主轴为垂直方向，从上向下排列column-reverse 主轴为垂直方向，从下向上排列flex-wrap 定义是否新行显示，以及新行的排列方向nowrap 默认值，显示在同一行，不换行wrap 一行显示不了时使用新行显示wrap-reverse 同 wrap，但是从下向上显示flex-flow 是 flex-direction 和 flex-wrap 的简写方式使用方法 flex-flow: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt;默认值为： row nowrapjustify-content 定义弹性项目在主轴上的对齐方式flex-start 默认值，从起始位置对齐，通常为左对齐flex-end 从结束位置对齐，通常为右对齐center 居中对齐space-between 两端对齐，平均间隔space-around 每个子元素都有相等的外边距，相邻元素外边距不会叠加align-items 定义弹性项目在侧轴上的对齐方式stretch 默认值，弹性项目在没指定高度或者高度为 auto 的情况下，则高度会占满空间flex-start 侧轴起点开始对齐flex-end 从侧轴结束位置对齐center 相对侧轴居中对齐baseline 与基线对齐align-content 定义多行在侧轴的对齐方式，当只有一行时，不起作用stretch 默认值，各行会伸展以占满整个纵轴空间flex-start 对齐到纵轴起点flex-end 对齐到纵轴终点center 相对纵轴中间对齐space-between 各行相对纵轴两端对齐，各行间隔相等space-around 各行都有相等的外边距，各行的外边距不会叠加弹性项目：flex-grow 数字，定义弹性项目的放大比例，默认 0flex-shrink 数字，定义弹性项目的缩小比例，默认 1，值 0 表示不缩小flex-basis 数字，定义弹性项目的默认尺寸，flex 是 flex-grow flex-shrink flex-basis 的缩写，默认值为 0 1 autoalign-self 定义此弹性项目本身的对齐方式，会覆盖弹性容器 align-items 定义的对齐方式auto 从弹性容器继承stretch 弹性项目在没指定高度或者高度为 auto 的情况下，则高度会占满空间flex-start 侧轴起点开始对齐flex-end 从侧轴结束位置对齐center 相对侧轴居中对齐baseline 与基线对齐order 数字，定义弹性项目的显示顺序，数字越小越靠前JS部分事件冒泡/捕获/委托事件流：事件捕获阶段（从上到下） -&gt; 处于目标阶段 -&gt; 事件冒泡阶段（从下到上）监听方法addEventListener(event, function, useCapture)event：事件名，支持所有DOM事件function：指定事件触发时执行的函数useCapture（可选）：指定事件是否在捕获或冒泡阶段执行。true：捕获。false：冒泡。默认false处于目标阶段时，没有捕获与冒泡之分，执行顺序按照addEventListener的添加顺序决定。使用stopPropagation()取消事件传播时，事件不会被传播给下一个节点，但同一节点的其他listener还是会执行。事件委托：利用事件冒泡，在所需DOM树最高层上添加一个事件处理程序适合事件委托事件： click、mousedown、mouseup、keydown、keyup、keypress阻止默认事件主流浏览器：event.preventDefault();ie：event.returnValue = false;其他：return false;匿名函数优点避免占用全局变量名，保护全局环境匿名函数是一个独立的作用域，传参可以保护临时变量，组件化开发时将命名空间传递到函数中用闭包保护起来，即使命名空间被后面代码重叠，也会利用闭包保护内部生态。缺点没有名字，调试代码时报错，但无法说明其错误根源是什么。匿名函数事件不能解绑。原始值和引用值原始值：Number、String、Boolean、undefined、null、Symbol（表示独一无二的值）引用值： Object（Array）、function、Date()、regEXP()原始值存储在栈中，变量可以直接访问到 -&gt; 系统自动分配释放引用值存储在堆中，值是一个指针，指向内存地址 -&gt; 动态分配内存空间，程序员可进行分配和释放（动态分配类似链表）如何判断一个数组var arr = []Array.isArray(arr) === trueObject.prototype.toString.call(arr) === ‘[object Array]’arr instanceof Array === truearr.constructor === Array数组去重作用域及作用域链js作用域分为：全局作用域、局部作用域作用域定义：当函数执行时，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，它所产生的执行上下文就会被销毁。简单来说在作用域内声明函数会创建函数作用域子节点，遇{}会创建块级作用域子节点，从而形成作用域链。[[scope]]每个JS函数都是一个对象，对象中有些属性我们可以访问，但有的不可以，这些属性仅供JS引擎存取。[[scope]]就是一个。它就是指作用域，其中存储了运行期上下文的集合，这个集合是链式连接，它就是作用域链。变量值查找在当前作用域往上查找，找到第一个匹配的标识符时就会停止返回变量值，如果查找全局作用域都没有，则抛出reference error错误，因此变量值查找有就近原则。es6中块级作用域的实现（闭包和变量改名）由于是es6的东西，所以有很多浏览器以前的JS引擎不支持，所以出现了babel编译神器，需要将es6的代码编译成低版本的JS引擎的代码。let 和 var 和 const 的区别var function声明的变量会依附最近的函数作用域或全局作用域。es6中let、const声明的变量依附于最近的块级作用域、函数作用域或全局作用域。而变量声明是因为JS引擎有一个预编译的过程。js预编译会将变量提升。预编译步骤（4步骤）：1.创建 AO 对象。2.寻找形参和变量声明，将变量和形参作为AO对象的属性名添加到对象中，值为undefined。值得注意的是，函数声明不叫变量。3.将实参值和形参值相统一。4.在函数体里面寻找函数声明，将函数名作为属性名，值为这个函数的函数体。预编译会暗示全局变量：变量若未声明就赋值，即归属全局对象。一切声明的全局变量全是window属性。所以function函数声明会首先被提升，才是变量。而let和const是es6新特性，不会被提升。function，var在同一作用域重复声明变量，后者会覆盖前者，let和const会直接抛出语法错误。const声明变量的同时需要赋值，否则会抛出语法错误，且变量的指向不会变，而引用类型的内容可以变。故常用于声明常量和对象。闭包的理解和应用闭包在一个函数内部在定义一个函数，并且这个内部函数与外部函数的变量有关联，通过返回这个内部函数来访问外部函数里面的变量。当内部函数被保存到外部时，将会生成闭包。闭包会导致原有作用域链不释放，造成内存泄漏。闭包的作用实现公有变量（函数累加器）可以做缓存（存储结构）可以实现封装，属性私有化模块化开发，防止污染全局变量闭包的防范闭包会导致多个执行函数共用一个公有变量，如果不是特殊需要，应尽量防止这种情况发生。立即执行函数（没有声明，一次执行后释放，适合做初始化工作）: 解闭包的一个重要方法，通过另一个新闭包来消除上一个闭包的影响(function () {} ())           (function () {})()构造函数及new构造函数一种特殊的方法主要用来在创建对象时初始化对象，即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。1 在函数体最前面隐式的加上this2 执行this.xxx = xxx3 隐式的返回thisnew是什么？new其实是JS语法中的一个语法糖。当我们要创建一个对象的实例时。我们要去继承这个对象的原型。那么new的作用就是帮你自动完成4个步骤。①帮你创建一个新对象。 var obj = new Object(); ②帮你绑定原型。obj.<strong>proto</strong> = Object.prototype 将新对象的<strong>proto</strong>属性指向构造函数的prototype③帮你将this指向新对象。④帮你return新对象。但在这里注意构造函数是否有返回值。如果构造函数的返回值为基本数据类型（number，string，boolean，undefined，null）则返回临新对象。如果构造函数的返回值为对象类型，则返回这个对象类型。call/apply/bind/this其中call/apply作用都是改变this指向，区别只是后面传的参数形式不同。call(thisArg,[arg1,[arg2,[…]]])，apply(thisArg,[arrs])bind也能改变this指向。但是bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入bind()方法的第一个参数作为this，传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。this是一个指向。在函数预编译过程中this指向window对象。在全局作用域里this也指向window对象。最后<strong>this永远指向最后调用它的那个对象</strong>。那么我们如何改变this指向？①在函数内部使用 var that = this②使用apply、call、bind函数改变this指向③用new实例化一个对象④使用es6的箭头函数<strong>proto</strong>和prototypeJS中的<strong>proto</strong>总是指向prototype。在es6之前，我们要改变一个原型，要这样写：var F = fucntion(){};F.prototype = Father.prototype;var son = new F();这样我们就可以实现将son.<strong>proto</strong> = Father.prototype。而在es6中，我们就可以很方便了。因为使用object.create()方法：可以在原型上生成新的对象的实例。只需要这样写：function Father(){};var son = Object.creat(new Father);js时间线1、创建Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段document.readyState = ‘loading’。2、遇到link外部css，创建线程加载，并继续解析文档。（css异步加载，继续往下解析HTML结构，但不渲染，等JS加载完后在渲染）3、遇到script外部js，并且没有设置async、defer，浏览器加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。4、遇到script外部js，并且设置有async、defer，浏览器创建线程加载，并继续解析文档。对于async属性的脚本，脚本加载完成后立即执行。（异步禁止使用document.write()）5、遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。6、当文档解析完成，document.readyState = ‘interactive’。7、文档解析完成后，所有设置有defer的脚本会按照顺序执行。（注意与async的不同,但同样禁止使用document.write()）;8、document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。9、当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = ‘complete’，window对象触发load事件。10、从此，以异步响应方式处理用户输入、网络事件等。深拷贝、浅拷贝浅拷贝：原始类型为值传递，对象类型仍为引用传递。function clone(src, tar) { // src 源对象，tar 目标对象    var tar = tar || {};    for(var prop in src) {        tar[prop] = src[prop];    }    return tar;}ES6中，Object.assign可以实现对象的浅拷贝深拷贝：复制下所有属性，与原对象不在有联系。function deepCopy(src,tar){    var tar= tar|| {} ;    for (var prop in src){        if (typeof(src[prop]) == ‘object’){            tar[prop] = (src[prop].constructor === Array ) ? [] : {};            deepCopy(src[prop],tar[prop]);    } else {        tar[prop] = src[prop];        }    }    return tar;}数组方法slice(0)可以实现对数组的浅拷贝数组方法concat([])可以实现对数组的深拷贝显隐身类型转化DOM节点的类型节点的类型 与 对应的 nodeType（可用 nodeType 查看节点的 类型）元素节点————&gt;1 // 例：<div>属性节点————&gt;2 // 例：id,class文本节点————&gt;3 // 例：123注释节点————&gt;8 // 例：&lt;!—— ——&gt;document————&gt;9 // 例：#doucmentDocumentFragment————&gt;11选择元素节点选择元素节点的方法（6种）：1.document.getElementById // 在ie8以下的浏览器中，不区分大小写，而且标签的name属性也可以被当做id被选择出来2.document.getElementsByClassName // ie8及以下的版本中没有这种方法3.document.getElementsByTagName // 兼容所有浏览器4.document.getElementsByName // 只有部分标签的name可以生效，表单、表单元素、img、iframecss选择器:5.querySelector() // ie7及以下的版本中没有这种方法6.querySelectorAll() // ie7及以下的版本中没有这种方法遍历节点树 &amp; 遍历元素节点树节点树的遍历：1.dom.parentNode 查找父节点2.dom.childNodes 查找子节点们3.dom.firstChild 第一个子节点4.dom.lastChild 最后一个子节点5.dom.nextSibling 下一个兄弟节点6.dom.previousSibling 上一个兄弟节点元素节点树的遍历：1.dom.parentElement 返回当前元素的父元素节点2.dom.children 所有子元素节点3.dom.childElementCount 这个属性就是子元素节点的数量// dom.children.length === dom.childElementCount4.dom.nextElementSibling 下一个兄弟元素节点5.dom.previousElementSibling 上一个兄弟元素节点增 ／ 插 ／ 替换 ／ 删除 操作新增 dom 元素：1.创建元素节点 document.createElement()2.创建文本节点 document.createTextNode()3.创建注释节点 document.createComment()4.创建文档碎片 document.createDocumentFragment()插入 dom 元素：1.dom1.appendChild(dom2); // 在 dom1 中最后的位置插入 dom22.dom1.insertBefore(dom2, dom3); // 在 dom1 下，把 dom2 插入到 dom3 前BOMwindowwindow 对象表示浏览器中打开的窗口。window 对象上有特别多的方法，一般来讲，能全局使用的都是 window 对象上的方法，例如我们常用的一些：console，setInterval，setTimeout，navigator，screen，history，locationnavigatornavigator对象：1.navigator.userAgent 目前用户使用的是 pc端 还是 移动端，是什么 浏览器。问题：若是 移动端 跳转 移动端 url，若是 pc端 跳转 pc端 url？答案：if(/iphone|nokia|sony|ericsson|mot|samsung|sgh|lg|philips|panasonic|alcatel|lenovo|cldc|midp|wap|android|iPod/i.test(navigator.userAgent.toLowerCase())){    window.location.href=”移动端url”;} else {    window.location.href=”pc端url”;}screen对象：1.screen.availHeight/screen.availWidth 可以查看除了 window 任务栏之外的 屏幕 的 高度 和 宽度。2.screen.height/screen.width 返回 显示器 的 屏幕 的 高度 和 宽度,兼容的较少。3.screen.deviceXDPI/screen.deviceYDPI 返回显示屏幕的分辨率。historyhistory对象：1.history.length 浏览历史的长度。2.history.back() 进入到下一个历史页面。3.history.forward() 返回到上一个历史页面。4.history.go() 当参数是 正数 的时候，前进到 下一个 历史页面，当是 负数 的时候，回退到 上一个 历史页面。locationlocation对象：1.location.href 设置或返回当前的 url2.location.host 返回当前的主机名 和 当前的 URL 端口号3.location.search 设置或返回从 问号 开始的 URL（查询部分）4.location.hash 跳转到 相应的 id 的 元素 的 位置5.location.reload 重新加载 当前 页面class特性与继承继承（6种方法）：1. 原型链继承<code>function Father () {}function Son () {}Son.prototype = new Father()</code>缺点：会继承过多没有用的属性，造成大量的浪费。2. 构造函数继承 call / apply<code>function Father () {}function Son () {Father.call(this)}</code>缺点：这种方式不属于继承，也访问不了原型的原型。每次构造一个对象都要走一个构造函数，效率很低。3. 共享原型<code>function Father () {}function Son () {}Son.prototype = Father.prototype;</code>缺点：没办法改变子类的原型，一改就两个一起改了。4. object.create() <strong>在原型上生成新的对象的实例</strong><code>function Father () {}var son = Object.create(new Father);</code>缺点：object.creat方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象上。所以这个继承得到的不是类，只是得到对象。好处：这个方法在你想要改变一个的原型来创建实例而言会特别好用。5. 圣杯模式<code>var inherit = (function (){    var F = function(){};    return function (C,P){        F.prototype = P.prototype;        C.prototype = new F();        C.prototype.constructor = C;        C.prototype.uber = P;    }}());</code>F 函数的作用：沟通 P 和 C 的原型，这样我们改变 C 的原型的时候只会影响 F 而不会影响 P。6. extands（es6 方法）<code>`</code>class Father {}class Son extands Father {}promise在JS中，所有的代码都是单线程执行的，所以JS的所有网络操作，浏览器事件都必须异步执行。而异步需要大量回调函数会导致页面结构混乱，形成可怕的回调地狱，ES6的Promise就是一个语法糖，帮助我们规范化书写回调函数。（采用链式调用的方法异步执行JS）Promise对象有三个状体：Pending（起始状体，进行中），Resolved（成功），Rejected（失败）Pending –&gt; Resolved 或 Pending –&gt; Rejected ，状体改变后不会在变Promise 对象var promise = new Promise(function(resolved,rejected){});Promise.catch如果promise.then不传第二个参数，可以用promise.catch方法来获取promise对象失败时传来的数据，是rejected的语法糖jQuery的链式调用大部分人初看 jQuery.fn.init.prototype = jQuery.fn 这一句都会被卡主，很是不解。但是这句真的算是 jQuery 的绝妙之处。理解这几句很重要，分点解析一下：1）首先要明确，使用 $(‘xxx’) 这种实例化方式，其内部调用的是 return new jQuery.fn.init(selector, context, rootjQuery) 这一句话，也就是构造实例是交给了 jQuery.fn.init() 方法去完成。2）将 jQuery.fn.init 的 prototype 属性设置为 jQuery.fn，那么使用 new jQuery.fn.init() 生成的对象的原型对象就是 jQuery.fn ，所以挂载到 jQuery.fn 上面的函数就相当于挂载到 jQuery.fn.init() 生成的 jQuery 对象上，所有使用 new jQuery.fn.init() 生成的对象也能够访问到 jQuery.fn 上的所有原型方法。3）也就是实例化方法存在这么一个关系链  jQuery.fn.init.prototype = jQuery.fn = jQuery.prototype ;new jQuery.fn.init() 相当于 new jQuery() ;jQuery() 返回的是 new jQuery.fn.init()，而 var obj = new jQuery()，所以这 2 者是相当的，所以我们可以无 new 实例化 jQuery 对象。网络get/post</div></p>
<pre><code>* GET在浏览器回退时是无害的，而POST会再次提交请求。
* GET产生的URL地址可以被Bookmark，而POST不可以。
* GET请求会被浏览器主动cache，而POST不会，除非手动设置。
* GET请求只能进行url编码，而POST支持多种编码方式。
* GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
* GET请求在URL中传送的参数是有长度限制的，而POST么有。
* 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
* GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
* GET参数通过URL传递，POST放在Request body中。
</code></pre><p>StrongeTCP/IP 三次握手，四次挥手三次握手：</p>
<pre><code>* 客户端–发送带有SYN标志的数据包–一次握手–服务端
* 服务端–发送带有SYN/ACK标志的数据包–二次握手–客户端
* 客户端–发送带有带有ACK标志的数据包–三次握手–服务端
</code></pre><p>四次挥手：</p>
<pre><code>* 客户端-发送一个FIN，用来关闭客户端到服务器的数据传送
* 服务器-收到这个FIN，它发回一个ACK，确认序号为收到的序号加1 。和SYN一样，一个FIN将占用一个序号
* 服务器-关闭与客户端的连接，发送一个FIN给客户端
* 客户端-发回ACK报文确认，并将确认序号设置为收到序号加1
</code></pre><p>ajax/fetchajaxajax不是一种单一的技术，而是有机利用一系列交互式网页应用相关的技术所形成的结合体。ajax是一种用于创建快速动态网页的技术，通过在后台与服务器进行少量数据交换，ajax可以使网页实现异步更新。意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。ajax 优缺点ajax 优点:</p>
<pre><code>1. 页面无刷新，用户体验好
2. 使用异步的形式与服务器进行通信，响应更快
3. 减少冗余请求，减轻服务器的负担
4. 基于标准化的并被广泛支持的技术，不需要插件或者小程序
</code></pre><p>AJAX缺点:</p>
<pre><code>1. 不支持浏览器的后退机制
2. 对搜索引擎支持较弱
3. 无法使用URL直接访问
4. 破坏了程序异常机制
5. 存在一定安全问题
</code></pre><p>ajax包含技术</p>
<pre><code>1. 使用CSS和XHTML表示
2. 使用javascript来绑定和调用
3. 使用DOM模型来交互和动态显示
4. 使用XMLHttpRequest来和服务器进行异步通信
</code></pre><p>XMLHttpRequest目前虽然还没有被W3C所采纳，但它已经是一个事实的标准，因为目前几乎所有的主流浏览器都支持它ajax 步骤通过XMLHttpRequest对象来向服务器发起异步请求，从服务器获取数据，用JavaScript来操作DOM更新页面</p>
<pre><code>1. 创建 ajax 对象var xml = XMLHttpRequest() //主流浏览器var xml = ActiveXObject(‘Mircosoft.XMLHTTP’) //IE5、IE6
2. 创建与服务器的连接和调用xml.open(get/post, url, anync) // 第三个参数是boolean值，默认为true，异步模式
3. 监听对象状态改变xml.onReadyStateChange //监听对象状态改变xml.readyState == 4 //响应已完成 返回0：请求未初始化; 返回1：请求已建立，但还没发送(send还没调用); 返回2：请求已发送，正在处理(通常现在可以获取到响应头); 返回3.请求正在处理中(通常现在可以获取到响应的部分数据，但服务器还没有完成响应的生成);xml.status == 200 //“OK：请求已经被服务器正常处理”callBack(responseText) // 若成功，通过回调函数接收 ajax 返回的数据
4. 向服务器发送数据xml.send()


* 使用GET请求：将要提交的参数写到open方法里的url里，send传参为null或空。
</code></pre><p>xml.open(“GET”, url + ‘?’ + data, flag);xml.send(null) 或 xml.send() * 使用POST请求：若要像HTML表单那样POST数据，使用setRequestHeader()来添加HTTP头，然后在send()方法里规定希望发送的数据格式<br>xml.open(“POST”, url, flag);xml.setRequestHeader(‘Content-type’, ‘application/x-www-form-urlencoded’);xml.send(data);<br>为什么监听要放到发送数据前边？因为因为现在网速是越来越快了，若网速非常快，刚刚请求数据，数据就已经返回回来了，但是代码还没有走到监听部分，这就导致了监听部分的失效。封装 ajaxfunction Ajax(method, url, flag, data, callback){var xml = null;//兼容性if(window.XMLHttpRequest) {xml = new XMLHttpRequest();}else {xml = new ActiveXObject(‘Microsoft.XMLHTTP’);}//将method值变为大写method = method.toUpperCase();//判断请求方式if(method === ‘GET’){xml.open(method, url + ‘?’ + data, flag);xml.send();}else if(method === ‘POST’){xml.open(method, url, flag);xml.setRequestHeader(‘Content-type’, ‘application/x-www-form-urlencoded’);xml.send(data);}//监听xml.onreadystatechange = function () {if(xml.readyState === 4) {if(xml.status === 200) {callback(xml.responseText);}else{alert(‘error’);}}}}FetchFetch API：Fetch 是 XMLHttpRequest 的最新替代技术。Fetch API 提供了一个 fetch() 方法，被定义在 BOM 的 window 对象中。Fetch 方法返回的是一个 Promise 对象，让你能够对 请求 的 返回结果 进行检索。Fetch 的优点：</p>
<pre><code>1. 语法简洁，更加语义化
2. 基于标准 Promise 实现，可以链式调用，支持 async/await
</code></pre><p>Fetch返回的response{body: ReadableStreambodyUsed: falseheaders: Headersok : trueredirected : falsestatus : 200statusText : “OK”type : “cors”url : “<a href="http://some-website.com/some-url&quot;__proto_" target="_blank" rel="noopener">http://some-website.com/some-url&quot;__proto_</a>_ : Response}Fetch 的使用：//fetch获取数据fetch(url).then(function (res) { // 需要同源策略return res.json();}).then(function (data) {console.log(data);}).catch(function (err) {console.log(err);})//fetch发送数据const data = {data:’content’};fetch(url, {method: ‘post’,headers: {‘Content-Type’:’application/json’},body:JSON.stringify(data)})Fetch处理异常 zlFetchFetch不会关心ajax是否成功，它只关心从服务器发送请求和接收响应。所以我们应该在响应失败时去抛出异常。那么我们可以使用zlFetch库，它会来帮我们进行异常处理。只需要安装一下zlFetchnpm install zl-fetch –save引入zlFetch//正常JS引入const zlFetch = require(‘zl-fetch’)//ES6引入import zlFetch from ‘zl-fetch’Fetch和zlFetch使用区别zlFetch还能无须转换成JSON格式就能发送JSON数据const data = {data:’content’};//Fetchfetch(url, {method: ‘post’,headers: {‘Content-Type’:’application/json’},body:JSON.stringify(data)})//zlFetchzlFetch(url, {method: ‘post’,body: data});Fetch是很好的方法，能发送和接收数据。不需要在编写XHR请求或依赖于jQuery。尽管Fetch很好，但是其错误处理不是很直接。在处理之前，需要让错误信息进入到catch方法中。使用zlFetch库，就不需要担心错误处理了。跨域跨域的方法</p>
<pre><code>1. flash
2. 服务器代理中转 // 将资源放在服务器上
3. iframe + document.domain // 主域名相同，子域名不同，在子页面 与 主页面 分别加上 document.domain
4. iframe + location.hash // 用 location.hash 值传递数据，将数据放到 url 里
5. iframe + window.name // 修改子页面的 window.name 让主页面获取到这个值
6. postMessage // 使用 iframe.contentWindow.postMessage 发送数据，在子页面绑定 message 事件接收数据
7. jsonp // script 标签 src 属性 不受同源策略限制
8. cors // 跨域资源共享，需要 浏览器 与 服务器 同时支持
</code></pre><p>后面两种现在比较常用！jsonp原理 jsonp：web 页面上 script 标签的 src 属性引入 js 文件不受跨域的影响，把资源直接放到 script 标签的 src 里面，相当于把 数据 以 json 的形式放到服务器上。无法监控 script 的 src 的加载状态，不知道数据有没有获取完成，所以我们要事先定义好处理函数，这个处理函数就是 jsonp。jsonp 的工作原理：script 标签的 src 向服务器发送了一个 GET 请求，同时 将约定好 的参数写到 url 上面。同源策略 只限制客户端，服务器端没有这个限制，因此服务器端 接收到 这个请求之后会 响应它。根据 url 上面的 参数 自动生成一串 json 数据 并且 格式化，然后返回到 发送请求 的页面上。script 标签获取到这个 字符串 之后 自动转化成 js 对象，然后执行这一段代码。jsonp 优点：</p>
<pre><code>1. JSONP 可以跨越同源策略
2. 兼容性好
3. 可以定义 callback 处理函数，处理函数交给了调用方
</code></pre><p>jsonp 缺点：</p>
<pre><code>1. 只支持 GET 请求而不支持 POST 请求
2. 调用失败的时候不会返回各种 HTTP 状态码
3. 安全性不高
</code></pre><p>CORS网络请求过程（在浏览器输入url）</p>
<pre><code>* 输入地址
* 浏览器查找域名的 IP 地址 这一步包括 DNS 具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存...
* 浏览器向 web 服务器发送一个 HTTP 请求  
* 服务器的永久重定向响应（从http://www.example.com到http://www.example）
* 浏览器跟踪重定向地址
* 服务器处理请求
* 服务器返回一个 HTTP 响应
* 浏览器显示 HTML    (以下部分具体可看JS时间线)
* 浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）
* . 浏览器发送异步请求
</code></pre><p>HTTPHttp协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。所以Http连接是一种短连接，是一种无状态的连接。所谓的无状态，是指浏览器每次向服务器发起请求的时候，不是通过一个连接，而是每次都建立一个新的连接。如果是一个连接的话，服务器进程中就能保持住这个连接并且在内存中记住一些信息状态。而每次请求结束后，连接就关闭，相关的内容就释放了，所以记不住任何状态，成为无状态连接。HTTP1.1 与 HTTP2.0区别HTTP的基本优化影响一个 HTTP 网络请求的因素主要有两个：带宽和延迟。</p>
<pre><code>* 带宽：如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。
* 延迟：

    * 浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。
    * DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。
    * 建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。
</code></pre><p>HTTP1.0和HTTP1.1的一些区别HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p>
<pre><code>1. 缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
2. 带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
3. 错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
4. Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
5. 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
</code></pre><p>HTTPS与HTTP的一些区别</p>
<pre><code>* HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
* HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
* HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
* HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。
</code></pre><p>TCP和UDP的区别通用的 TCP 和 UDP 协议</p>
<pre><code>* TCP 协议面向有连接，能正确处理丢包，传输顺序错乱的问题，但是为了建立与断开连接，需要至少7次的发包收包，资源浪费
* UDP 面向无连接，不管对方有没有收到，如果要得到通知，需要通过应用层
</code></pre><p>HTTP常见状体码2XX 成功</p>
<pre><code>* 200 OK，表示从客户端发来的请求在服务器端被正确处理
* 204 No content，表示请求成功，但响应报文不含实体的主体部分
* 206 Partial Content，进行范围请求
</code></pre><p>3XX 重定向</p>
<pre><code>* 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
* 302 found，临时性重定向，表示资源临时被分配了新的 URL
* 303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源
* 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
* 307 temporary redirect，临时重定向，和302含义相同
</code></pre><p>4XX 客户端错误</p>
<pre><code>* 400 bad request，请求报文存在语法错误
* 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
* 403 forbidden，表示对请求资源的访问被服务器拒绝
* 404 not found，表示在服务器上没有找到请求的资源
</code></pre><p>5XX 服务器错误</p>
<pre><code>* 500 internal sever error，表示服务器端在执行请求时发生了错误
* 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求
</code></pre><p>HTTP缓存HTTP缓存头部简述http的(nginx)服务器可以直接升级到https吗？http1.0短连接可以实现长连接吗？网络安全XSS链接型反射型存储型防御：过滤非法字符（利用正则匹配），限制长度（截断）设计模式观察者模式MVC模式 、 MVVM模式工厂模式单例模式中介者模式 装饰者模式前端工程化前端性能优化VUEVue生命周期new Vue() -&gt; Init(Event &amp; Lifecycle) -&gt; beforeCreate -&gt; init(injections &amp; reactivity) -&gt; created -&gt; Has ‘el’ option? ( -N&gt; when vm.$mount(el) is called -&gt; ) -Y&gt;  Has ‘template’ options  ( -N&gt; Compile el’s outerHTML as template <em> ) (-Y&gt; Compile template into render funcrion </em> ) -&gt; beforeMount -&gt; Create vm.$el and replace ‘el’ with it -&gt; mounted -&gt; Mounted (-&gt; when data changes -&gt; beforeUpdate -OR&gt; updated -&gt; Virtual Dom re-render and patch) -&gt; when vm.$destroy() is called -&gt; beforeDestroy -&gt; Teardown watchers, child components and event listeners -&gt; Destroyed -&gt; destroyed方法生命周期beforeCreate -&gt; created -&gt; beforeMount -&gt; mounted -&gt; ( beforeUpdate -OR&gt; updated) -&gt; beforeDestroy -&gt; destroyed 创建Vue实例 -&gt; 初始化事件和生命周期，初始化_init是vue设置在prototype的私有属性，初始化时，_init里有一个属性是vm._uid，每次创建一个Vue实例时加1，以确保每一个Vue实例都是独一无二的。-&gt;初始化注入和反应-&gt; 是否有el属性，若无看是否使用$mount方法挂载，满足则进入下一个周期-&gt; 是否有template模板属性-&gt; 如果没有，则将挂载的el对象的外部HTML作为template模板，如果有则编译template模板进入render渲染函数-&gt; 创建虚拟el替代Vue实例里的el-&gt; （在更新前当数据发生变化 或者 更新 则触发虚拟DOM进行重新渲染re-render 和 产生补丁patch)-&gt; 开始销毁虚拟Vue-&gt; 卸载watchers, child, components 和 eventlisteners-&gt; 销毁，结束Vue双向数据绑定       每当 new 一个 Vue，主要做了两件事：第一个是监听数据：observe(data)，第二个是编译 HTML：nodeToFragement(id)。       在监听数据的过程中，会为 data 中的每一个属性生成一个主题对象 dep。       在编译 HTML 的过程中，会为每个与数据绑定相关的节点生成一个订阅者 watcher，watcher 会将自己添加到相应属性的 dep 中。       修改输入框内容 =&gt; 在事件回调函数中修改属性值 =&gt; 触发属性的 set 方法。       发出通知 dep.notify() =&gt; 触发订阅者的 update 方法 =&gt; 更新视图。vuex Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vueRoute的实现方式，若前端hash值改变，如何通知数据层</p>

            
        </div>
    
</div>


                
                    <!-- Paradox Post Info -->
                    
                

                <!-- Post Comments -->
                
                    
                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2018/04/11/Promise/" id="post_nav-older" class="next-content">
            Älteren
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?V/53wGualMuiPM3xoetD5Q==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>













<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.2 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
